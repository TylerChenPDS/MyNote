# TCP

## 画出TCP的报头

![image-20210311123939387](https://gitee.com/CTLQAQ/picgo/raw/master/image-20210311123939387.png)

解释

序号：Seq序号，占32位，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。

确认序号：Ack序号，占32位，只有ACK标志位为1时，确认序号字段才有效，Ack=Seq+1。

**标志位**：共6个，即URG、ACK、PSH、RST、SYN、FIN等，具体含义如下：

（A）URG：紧急指针（urgent pointer）有效。

（B）ACK：确认序号有效。

（C）PSH：接收方应该尽快将这个报文交给应用层。

（D）RST：重置连接。

（E）SYN：发起一个新连接。

（F）FIN：释放一个连接。



（A）不要将确认序号Ack与标志位中的ACK搞混了。

（B）确认方Ack=发起方Req+1，两端配对。



## TCP建立连接的三次握手

![image-20210218195747846](https://gitee.com/CTLQAQ/picgo/raw/master/image-20210218195747846.png)

1. 第一次握手：**客户端向处于LISTEN状态的服务器发送：标志位SYN为1，序列号为x的包，并且自己进入SYN_SEND状态**
2. 第二次握手：**服务器发送：标志位SYN，ACK为1，序列号为y，确认号为y+1的包，并且自己进入SYN_REVD状态**
3. 第三次握手：**客户端发送：标志位ACK=1，确认号为y + 1, 序列号为x+1的包，然后双方处于建立连接状态**

**为什么需要最后一次确认？**

**防止已经失效的连接请求突然又传送到服务器，造成错误。**如果没有随后一次确认，假设一种异常情况：客户端A发送了一个连接请求，结果这个请求在某些节点滞留了，A长时间没收到响应，于是又发送一个请求。第二次请求得到了确认，于是建立连接，数据传输后，释放了连接。然后那个滞留的请求到了，于是又会建立一个连接，但是A不需要发送数据，服务器B却一直等待A发送数据，导致B的许多资源白白浪费了。



为什么要三次握手

- 三次握手才可以阻止重复历史连接的初始化（主要原因）  
- 三次握手才可以同步双方的初始序列号  
- 三次握手才可以避免资源浪费  

举例：

**重复的历史连接**

![image-20210311124503284](https://gitee.com/CTLQAQ/picgo/raw/master/image-20210311124503284.png)



客户端连续发送多次 SYN 建立连接的报文，在网络拥堵情况下：

- 一个「旧 SYN 报文」比「最新的 SYN 」 报文早到达了服务端；

- 那么此时服务端就会回一个 SYN + ACK 报文给客户端；

- 客户端收到后可以根据自身的上下文，判断这是一个历史连接（序列号过期或超时），那么客户
  端就会发送 RST 报文给服务端，表示中止这一次连接。
- 如果是历史连接（序列号过期或超时），则第三次握手发送的报文是   RST 报文，以此中止历史连接；
- 如果不是历史连接，则第三次发送的报文是ACK  报文，通信双方就会成功建立连接

**同步双方初始序列号**  

TCP 协议的通信双方， 都必须维护一个「序列号」， 序列号是可靠传输的一个关键因素，它的作用：  

- 接收方可以去除重复的数据；

- 接收方可以根据数据包的序列号按序接收；

- 可以标识发送出去的数据包中， 哪些是已经被对方收到的；  

可见，序列号在 TCP 连接中占据着非常重要的作用，所以当客户端发送携带「初始序列号」的 SYN报文的时候，需要服务端回一个 ACK 应答报文，表示客户端的 SYN 报文已被服务端成功接收，那当服务端发送「初始序列号」给客户端的时候，依然也要得到客户端的应答回应，这样一来一回，才能确保双方的初始序列号能被可靠的同步 。四次握手其实也能够可靠的同步双方的初始化序号，但由于第二步和第三步可以优化成一步，所以就成了「三次握手」。  

而两次握手只保证了一方的初始序列号能被对方成功接收，没办法保证双方的初始序列号都能被确认接收。

**避免资源浪费**    

如果只有「两次握手」，当客户端的 SYN 请求连接在网络中阻塞，客户端没有接收到 ACK 报文，就会重新发送 SYN ，由于没有第三次握手，服务器不清楚客户端是否收到了自己发送的建立连接的ACK 确认信号，所以每收到一个 SYN 就只能先主动建立一个连接，这会造成什么情况呢？  如果客户端的 SYN 阻塞了，重复发送多次 SYN 报文，那么服务器在收到请求后就会建立多个冗余的无效链接，造成不必要的资源浪费  。



## 四次挥手

![image-20210228225612403](https://gitee.com/CTLQAQ/picgo/raw/master/image-20210228225612403.png)

a)   客户端发送标志位FIN为1，序列号为x的包，

b)   服务器发送标志位ACK=1，序列号=y，确认号=x+1的包， 此时A到B方向的连接就释放了，此时TCP连接处于半连接状态，即A已经没有数据要发送了，但是B如果有数据发送A仍然要接收。

c)   服务器B数据发送完了向A发送：标志位FIN=1，ACK=1，seq=z，ack=x+1

d)   A发送 ACK=1，seq=x+1，ack=z+1 注意，此时tcp连接并没有释放，必须经过时间等待计时器**2MSL（最长报文段寿命时间 Maximum Segment Lifetime）**时间后才能释放。

MSL: 它是任何报文在网络上存在的最长的最长时间，超过这个时间报文将被丢弃。

**为啥最后挥手要等2MSL？**

为了保证A发送的最后一个ACK能够到达B。因为A的ACK报文可能会丢失。

1. 为了保证可靠的断开TCP的双向连接，确保足够的时间让对方收到ACK包。若客户端回复的ACK丢失，server会在超时时间到来时，重传最后一个fin包，处于TIME_WAIT状态的client可以继续回复Fin包，发送ACK。
2. 保证让迟来的TCP报文段有足够的时间被识别和丢弃，避免新旧连接混淆。有些路由器会缓存没有收到的数据包，如果新的连接开启，这些数据包可能就会和新的连接中的数据包混在一起。连接结束了，网络中的延迟报文也应该被丢弃掉，以免影响立刻建立的新连接。

2MSL 的时间是从客户端接收到 FIN 后发送 ACK 开始计时的。如果在 TIME-WAIT 时间内，因为客
户端的 ACK 没有传输到服务端，客户端又接收到了服务端重发的 FIN 报文，那么 2MSL 时间将重新计
时。  

![image-20210311135553531](https://gitee.com/CTLQAQ/picgo/raw/master/image-20210311135553531.png)



为什么要四次挥手？

- 关闭连接时，客户端向服务端发送 FIN 时，仅仅表示客户端不再发送数据了但是还能接收数据。

- 服务器收到客户端的 FIN 报文时，先回一个 ACK 应答报文，而服务端可能还有数据需要处理
  和发送，等服务端不再发送数据时，才发送 FIN 报文给客户端来表示同意现在关闭连接。  





## 从输入URL到浏览器显示页面发生了什么？

1. 游览器首先会解析这个域名，首先它会查看本地硬盘的 hosts 文件，看看其中有没有和这个域名对应的规则，如果有的话就直接使用 hosts 文件里面的 ip 地址。
2. 如果在本地的 hosts 文件没有能够找到对应的 ip 地址，浏览器会发出一个 DNS请求到本地DNS(域名分布系统)服务器 。本地DNS服务器一般都是你的网络接入服务器商提供，比如中国电信，中国移动。
3. 拿到ip地址之后，会向web服务器发起TCP连接请求，最终三次握手建立连接
4. 浏览器向web服务器发起http请求
5. 服务器解析用户的请求，调度响应的资源文件，返回给客户端浏览器
6. 断开连接，4次挥手。



1. DNS解析
2. TCP连接
3. 发送HTTP请求
4. 服务器处理请求并返回HTTP报文
5. 浏览器解析渲染页面
6. 连接结束



## OSI与TCP/IP 各层

![image-20210301095959691](https://gitee.com/CTLQAQ/picgo/raw/master/image-20210301095959691.png)

应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。http，dns

运输层(transport layer)的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务。

1. **传输控制协议 TCP**（Transmission Control Protocol）--提供**面向连接**的，**可靠的**数据传输服务。
2. **用户数据协议 UDP**（User Datagram Protocol）--提供**无连接**的，尽最大努力的数据传输服务（**不保证数据传输的可靠性**）。

网络层的任务就是选择合适的网间路由和交换结点， 确保数据及时传送。

**数据链路层(data link layer)通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。** 在两个相邻节点之间传送数据时，**数据链路层将网络层交下来的 IP 数据报组装成帧**，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。

**物理层(physical layer)的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异，** 使其上面的数据链路层不必考虑网络的具体传输介质是什么。





## TCP与UDP的区别

## ![image-20210301100958965](https://gitee.com/CTLQAQ/picgo/raw/master/image-20210301100958965.png)TCP如何保障可靠传输

1. 应用数据被分割成 TCP 认为最适合发送的数据块。
2. TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。
3. **校验和：** TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。
4. TCP 的接收端会丢弃重复的数据。
5. **流量控制：** TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）
6. **拥塞控制：** 当网络拥塞时，减少数据的发送。
7. **ARQ协议：** 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。
8. **超时重传：** 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。

### 

## ARQ协议

**自动重传请求**（Automatic Repeat-reQuest，ARQ）通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送。

**停止等待ARQ协议**

- 它的基本原理就是每发完一个分组就停止发送，等待对方确认（回复ACK）。如果过了一段时间（超时时间后），还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，直到收到确认后再发下一个分组；
- 在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认；

**优点：** 简单

**缺点：** 信道利用率低，等待时间长

**连续ARQ协议**

发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。

**优点：** 信道利用率高，容易实现，即使确认丢失，也不必重传。

**缺点：** 不能向发送方反映出接收方已经正确收到的所有分组的信息。 比如：发送方发送了 5条 消息，中间第三条丢失（3号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 Go-Back-N（回退 N），表示需要退回来重传已经发送过的 N 个消息。



### 常见的重传机制

超时重传：

发送数据时设置一个定时器，当超过指定时间后，没有收到对方的ACK确认应答报文，就会重发该数据。会在2种情况下超时重传：1，数据包丢失。2，确认应答丢失。超时时间重传时间（RTO （Retransmission Timeout   ））应该略大于RTT(Round-Trip Time)，如果太大可能包丢失很久之后才会传增加了平均时延。如果太小可能有些包没有丢就重传了，会增加网络堵塞，导致更多的超时。

快速重传：

不以时间驱动，以数据驱动。三次重复的ACK就会触发重传机制。

![image-20210311114025708](https://gitee.com/CTLQAQ/picgo/raw/master/image-20210311114025708.png)

但是他还面临另外一个问题，是重传的时候，重传之前的一个，还是重传所有的。因为发送端不清楚三个连续的ACK是收到了哪个包之后传来的。

SACK (Selective Acknowledgment 选择性确认  )

方式需要在 TCP 头部「选项」字段里加一个 SACK 的东西，它可以将缓存的地图发送给发送方，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以只重传丢失的数据  

![image-20210311114254885](https://gitee.com/CTLQAQ/picgo/raw/master/image-20210311114254885.png)

Duplicate SACK  

Duplicate SACK 又称 D-SACK ，其主要使用了 SACK 来告诉「发送方」有哪些数据被重复接收了。  

![image-20210311114437613](https://gitee.com/CTLQAQ/picgo/raw/master/image-20210311114437613.png)



网络延迟的栗子

数据包（1000~1499） 被网络延迟了，导致「发送方」没有收到 Ack 1500 的确认报文。
而后面报文到达的三个相同的 ACK 确认报文，就触发了快速重传机制，但是在重传后，被延迟的
数据包（1000~1499）又到了「接收方」；
所以「接收方」回了一个 SACK=1000~1500，因为 ACK 已经到了 3000，所以这个 SACK 是 DSACK，表示收到了重复的包。
这样发送方就知道快速重传触发的原因不是发出去的包丢了，也不是因为回应的 ACK 包丢了，而
是因为网络延迟了。  

可见， D-SACK 有这么几个好处：

1. 可以让「发送方」知道，是发出去的包丢了，还是接收方回应的 ACK 包丢了;
2. 可以知道是不是「发送方」的数据包被网络延迟了;
3. 可以知道网络中是不是把「发送方」的数据包给复制了;  

## 滑动窗口和流量控制

**TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。** 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。

窗口大小就是指无需等待确认应答，而可以继续发送数据的最大值  。窗口的实现实际上是操作系统开辟的一个缓存空间，发送方主机在等到确认应答返回之前，必须在缓冲区中保留已发送的数据。如果按期收到确认应答，此时数据就可以从缓存区清除。  

**窗口大小由哪一方决定？**  TCP 头里有一个字段叫 Window ，也就是窗口大小。  这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。  所以，通常窗口的大小是由接收方的窗口大小来决定的。  

发送方的滑动窗口：

![image-20210311115911749](https://gitee.com/CTLQAQ/picgo/raw/master/image-20210311115911749.png)

![image-20210311115922844](https://gitee.com/CTLQAQ/picgo/raw/master/image-20210311115922844.png)

![image-20210311115935195](https://gitee.com/CTLQAQ/picgo/raw/master/image-20210311115935195.png)

程序使用的3个指针：

![image-20210311120155694](https://gitee.com/CTLQAQ/picgo/raw/master/image-20210311120155694.png)

接收方的滑动窗口

![image-20210311120331477](https://gitee.com/CTLQAQ/picgo/raw/master/image-20210311120331477.png)

接收窗口和发送窗口的大小是相等的吗？  

滑动窗口并不是一成不变的。比如，当接收方的应用进程读取数据的速度非常快的话，这样的话接
收窗口可以很快的就空缺出来。那么新的接收窗口大小，是通过 TCP 报文中的 Windows 字段来告诉发
送方。那么这个传输过程是存在时延的，所以接收窗口和发送窗口是约等于的关系。  



窗口关闭问题：

接收方向发送方通告窗口大小时，是通过 ACK 报文来通告的。  那么，当发生窗口关闭时，接收方处理完数据后，会向发送方通告一个窗口非 0 的 ACK 报文，如果这个通告窗口的 ACK 报文在网络中丢失了，那麻烦就大了。这会导致发送方一直等待接收方的非 0 窗口通知，接收方也一直等待发送方的数据，如不采取措施，这种相互等待的过程，会造成了死锁的现象。    

为了解决这个问题，TCP 为每个连接设有一个持续定时器，只要 TCP 连接一方收到对方的零窗口通知，就启动持续计时器  如果持续计时器超时，就会发送窗口探测 ( Window probe ) 报文，而对方在确认这个探测报文时，给出自己现在的接收窗口大小。  如果接收窗口仍然为 0，那么收到这个报文的一方就会重新启动持续计时器；如果接收窗口不是 0，那么死锁的局面就可以被打破了。 

窗口过小造成的资源浪费问题？（窗口字节数小于TCP报头的字节数）

出现原因：如果接收方太忙了，来不及取走接收窗口里的数据，那么就会导致发送方的发送窗口越来越小  。

2种解决方案

让接收方不通告小窗口给发送方

当「窗口大小」小于 min( MSS，缓存空间/2 ) ，也就是小于 MSS 与 1/2 缓存大小中的最小值时，就会
向发送方通告窗口为 0 ，也就阻止了发送方再发数据过来。  

让发送方避免发送小数据  

使用 Nagle 算法，该算法的思路是延时处理，它满足以下两个条件中的一条才可以发送数据：
1， 要等到窗口大小 >= MSS 或是 数据大小 >= MSS
2， 收到之前发送数据的 ack 回包  







## 拥塞控制

一般来说，计算机网络都处在一个共享的环境。因此也有可能会因为其他主机之间的通信使得网络拥堵。在网络出现拥堵时，如果继续发送大量数据包，可能会导致数据包时延、丢失等，这时 TCP 就会重传数据，但是一重传就会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，这个情况就会进入恶性循环被不断地放大  

为了在「发送方」调节所要发送数据的量，定义了一个叫做「拥塞窗口」的概念。  拥塞窗口 cwnd是发送方维护的一个的状态变量，它会根据网络的拥塞程度动态变化的  。引入了拥塞窗口之后，发送窗口的值是swnd = min(cwnd, rwnd)  

拥塞控制主要是四个算法：
慢启动
拥塞避免
拥塞发生
快速恢复  

- **慢开始：** 慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd初始值为1，每经过一个传播轮次，cwnd加倍。当拥塞窗口大于，慢启动门限 之后就会切换到拥塞避免算法。

- **拥塞避免：** 拥塞避免算法的思路是让拥塞窗口cwnd缓慢增大，即每经过一个往返时间RTT就把发送放的cwnd加1。所以，我们可以发现，拥塞避免算法就是将原本慢启动算法的指数增长变成了线性增长，还是增长阶
  段，但是增长速度缓慢了一些。  

- **拥塞发生算法** 。当网络出现拥塞，也就是会发生数据包重传，重传机制主要有两种：  超时重传  ，快速重传  。

  - 超时重传下的拥塞发生算法

  ![image-20210311123045222](https://gitee.com/CTLQAQ/picgo/raw/master/image-20210311123045222.png)

  

  - 发生快速重传的拥塞发生算法  

    TCP 认为这种情况不严重，因为大部分没丢，只丢了一小部分，则 ssthresh 和 cwnd 变化如下：
    1， cwnd = cwnd/2 ，也就是设置为原来的一半;
    2，慢启动门限 ssthresh = cwnd ;
    进入快速恢复算法  

- 快速恢复算法 。

  拥塞窗口 cwnd = ssthresh + 3 （ 3 的意思是确认有 3 个数据包被收到了）；
  重传丢失的数据包；
  如果再收到重复的 ACK，那么 cwnd 增加 1；
  如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 ssthresh 的值，原因是该 ACK 确认了新
  的数据，说明从 duplicated ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的
  状态了，也即再次进入拥塞避免状态；  

![image-20210311123841280](https://gitee.com/CTLQAQ/picgo/raw/master/image-20210311123841280.png)























# HTTP

## 定义：

超文本传输协议是一个在计算机世界里专门在2点之间传输文字、图片、音频视频等超文本的约定和数据。

## HTTP报文结构

![image-20210309153355466](https://gitee.com/CTLQAQ/picgo/raw/master/image-20210309153355466.png)

起始行+请求头部 = Header（请求头/响应头）， Body（可有可无）



![image-20210311174730932](https://gitee.com/CTLQAQ/picgo/raw/master/image-20210311174730932.png)

起始行由：方法、URL字段、HTTP版本



响应报文

- 第一行包含协议版本、状态码以及描述，最常见的是 200 OK 表示请求成功了
- 接下来多行也是首部内容
- 一个空行分隔首部和内容主体
- 最后是响应的内容主体

![image-20210311174745183](https://gitee.com/CTLQAQ/picgo/raw/master/image-20210311174745183.png)



## HTTP常见状态码

![image-20210309155823769](https://gitee.com/CTLQAQ/picgo/raw/master/image-20210309155823769.png)

## HTTP首部

有 4 种类型的首部字段：通用首部字段、请求首部字段、响应首部字段和实体首部字段。

![image-20210311181119287](https://gitee.com/CTLQAQ/picgo/raw/master/image-20210311181119287.png)



![image-20210311181134142](https://gitee.com/CTLQAQ/picgo/raw/master/image-20210311181134142.png)



![image-20210311181147047](https://gitee.com/CTLQAQ/picgo/raw/master/image-20210311181147047.png)

![image-20210311181200142](C:%5CUsers%5C19699%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210311181200142.png)

## Http1.0/1.1

在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。

而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，，会在响应头加入这行代码：

`Connection:keep-alive`

在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。

HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。

## HTTP 如何保存用户状态

HTTP 是一种无状态（stateless）协议。Session 机制的存在就是为了解决这个问题，Session 的主要作用就是通过服务端记录用户的状态。

大部分情况下，发送请求的时候，我们都是通过在 Cookie 中附加一个 Session ID 。



## Cookie 和 Session的区别？

Cookie 和 Session都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太一样。

cookie 是 Web 服务器发送给浏览器的一块信息。浏览器会在本地文件中给每一个 Web 服务器存储 cookie。以后浏览器在给特定的 Web 服务器发请求的时候，同时会发送所有为该服务器存储的 cookie。

无论客户端浏览器做怎么样的设置，session都应该能正常工作。客户端可以选择禁用cookie， 但是，session 仍然是能够工作的，因为客户端无法禁用服务端的 session。 在存储的数据量方面 session 和 cookies 也是不一样的。session 能够存储任意的 Java 对象， cookie 只能存储 String 类型的对象。

**Cookie 一般用来保存用户信息** 比如①我们在 Cookie 中保存已经登录过得用户信息，下次访问网站的时候页面可以自动帮你登录的一些基本信息给填了；②一般的网站都会有保持登录也就是说下次你再访问网站的时候就不需要重新登录了，这是因为用户登录的时候我们可以存放了一个 Token 在 Cookie 中，下次登录的时候只需要根据 Token 值来查找用户即可(为了安全考虑，重新登录一般要将 Token 重写)；③登录一次网站后访问网站其他页面不需要重新登录。**Session 的主要作用就是通过服务端记录用户的状态。**



## GET和POST的区别

- GET 用于获取资源，而 POST 用于传输实体主体。
- GET 和 POST 的请求都能使用额外的参数，但是 GET 的参数是以查询字符串出现在 URL 中，而 POST 的参数存储在实体主体中。因为 URL 只支持 ASCII 码，因此 GET 的参数中如果存在中文等字符就需要先进行编码。例如 `中文` 会转换为 `%E4%B8%AD%E6%96%87`，而空格会转换为 `%20`。
- 安全的 HTTP 方法不会改变服务器状态，也就是说它只是可读的。GET 方法是安全的，而 POST 却不是，因为 POST 的目的是传送实体主体内容，这个内容可能是用户上传的表单数据，上传成功之后，服务器可能把这个数据存储到数据库中，因此状态也就发生了改变。安全的方法除了 GET 之外还有：HEAD、OPTIONS。不安全的方法除了 POST 之外还有 PUT、DELETE。
- 幂等性。幂等的 HTTP 方法，同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。在正确实现的条件下，GET，HEAD，PUT 和 DELETE 等方法都是幂等的，而 POST 方法不是。



## 跨域问题

跨域：指的是浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是浏览器对javascript施加的安全限制。例如：a页面想获取b页面资源，如果a、b页面的协议、域名、端口、子域名不同，所进行的访问行动都是跨域的，而浏览器为了安全问题一般都限制了跨域访问，也就是不允许跨域请求资源。注意：跨域限制访问，其实是**浏览器的限制**。理解这一点很重要！！

同源策略：是指协议，域名，端口都要相同，其中有一个不同都会产生跨域；

可以使用nginx进行代理





# Https

## HTTP和HTTPS的区别

1. **端口** ：HTTP的URL由“http://”起始且默认使用端口80，而HTTPS的URL由“https://”起始且默认使用端口443。
2. HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输。  
3. HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。  
4. HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的  

## HTTPS如何解决信息加密，校验机制（防止篡改）身份认证？

- 混合加密的方式实现信息的机密性，解决了窃听的风险。

- 摘要算法的方式来实现完整性，它能够为数据生成独一无二的「指纹」，指纹用于校验数据的完整性，解决了篡改的风险。

- 将服务器公钥放入到数字证书中，解决了冒充的风险  

**混合加密**

HTTPS 采用的是对称加密和非对称加密结合的「混合加密」方式：

- 在通信建立前采用非对称加密的方式交换「会话秘钥」，后续就不再使用非对称加密。

- 在通信过程中全部使用对称加密的「会话秘钥」的方式加密明文数据。  

采用「混合加密」的方式的原因：  

- 对称加密只使用一个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换  
- 非对称加密使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题但
  速度慢。  

**摘要算法**

摘要算法用来实现完整性，能够为数据生成独一无二的「指纹」，用于校验数据的完整性，解决了篡改的风险。  

客户端在发送明文之前会通过摘要算法算出明文的「指纹」，发送的时候把「指纹 + 明文」一同加密成密文后，发送给服务器，服务器解密后，用相同的摘要算法算出发送过来的明文，通过比较客户端携带的「指纹」和当前算出的「指纹」做比较，若「指纹」相同，说明数据是完整的。  

**数字证书**  

客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。  

这里就需要借助第三方权威机构 CA （数字证书认证机构），将服务器公钥放在数字证书（由数字证书认证机构颁发）中，只要证书是可信的，公钥就是可信的。  

![image-20210311153529719](https://gitee.com/CTLQAQ/picgo/raw/master/image-20210311153529719.png)

## SSL / TSL 的工作流程

安全套接层，安全传输层协议。

**ClientHello**  

首先，由客户端向服务器发起加密通信请求，也就是 ClientHello 请求 。在这一步，客户端主要向服务器发送以下信息：  

- 客户端支持的 SSL/TLS 协议版本，如 TLS 1.2 版本。  
- 客户端生产的随机数（ Client Random ），后面用于生产「会话秘钥」  
- 客户端支持的密码套件列表，如 RSA 加密算法。  

**SeverHello**  

服务器收到客户端请求后，向客户端发出响应，也就是 SeverHello 。服务器回应的内容有如下内容：  

- 确认 SSL/ TLS 协议版本，如果浏览器不支持，则关闭加密通信。  
- 服务器生产的随机数（ Server Random ），后面用于生产「会话秘钥」。  
- 确认的密码套件列表，如 RSA 加密算法  

- **服务器的数字证书**  

**客户端回应**  

客户端收到服务器的回应之后，首先通过浏览器或者操作系统中的 CA 公钥，确认服务器的数字证书的真实性  。如果证书没有问题，客户端会从数字证书中取出服务器的公钥，然后使用它加密报文，向服务器发送如下信息：  

- 一个随机数（ pre-master key ）。该随机数会被服务器公钥加密。  
- 加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。  
- 客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供服务端校验  。

**上面第一项的随机数是整个握手阶段的第三个随机数，这样服务器和客户端就同时有三个随机数，接着
就用双方协商的加密算法，各自生成本次通信的「会话秘钥」**  

**服务器的最后回应**  

服务器收到客户端的第三个随机数（ pre-master key ）之后，通过协商的加密算法，计算出本次通信的「会话秘钥」。然后，向客户端发生最后的信息：  

- 加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。  
- 服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供客户端校验。  

至此，整个 SSL/TLS 的握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的 HTTP 协议，只不过用「会话秘钥」加密内容。  





# 参考

http://www.cyc2018.xyz/

https://snailclimb.gitee.io/javaguide/#/?id=java

https://www.jianshu.com/p/8fa2acd103ea