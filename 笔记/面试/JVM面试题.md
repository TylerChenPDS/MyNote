## JVM

### 介绍一下JAVA内存区域

1.8 之前

![image-20210125142015747](https://gitee.com/CTLQAQ/picgo/raw/master/image-20210125142015747.png)

1.8 

![image-20210125142426115](https://gitee.com/CTLQAQ/picgo/raw/master/image-20210125142426115.png)

**线程私有的：**

- 程序计数器
- 虚拟机栈
- 本地方法栈

**线程共享的：**

- 堆
- 方法区
- 直接内存(非运行时数据区的一部分)



**程序计数器**

程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。**字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完。**

主要作用：

- 实现代码的流程控制
- 现场恢复

**程序计数器是唯一一个不会出现 OutOfMemoryError 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。**



**Java虚拟机栈**

Java虚拟机栈也是线程私有的，它的**生命周期和线程相同**，**描述的是 Java 方法执行的内存模型**，每次方法调用的数据都是通过栈传递的。Java虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息。

**局部变量表主要存放了编译器可知的各种数据类型**（boolean、byte、char、short、int、float、long、double）、**对象引用**（reference类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置），returnAddress类型（指向了一条字节码指令的地址）。

**Java 虚拟机栈会出现两种异常：StackOverFlowError 和 OutOfMemoryError。**

**那么方法/函数如何调用？**

Java 栈中保存的主要内容是栈帧，每一次函数调用都会有一个对应的栈帧被压入Java栈，每一个函数调用结束后，都会有一个栈帧被弹出。

Java方法有两种返回方式：

1. return 语句。
2. 抛出异常。

不管哪种返回方式都会导致栈帧被弹出



**本地方法栈**

和虚拟机栈所发挥的作用非常相似，区别是： **虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。** 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。



**堆**	

java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。**此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。**

Java 堆是垃圾收集器管理的主要区域，因此也被称作**GC堆（Garbage Collected Heap）**.从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以Java堆还可以细分为：新生代和老年代：再细致一点有：Eden空间、From Survivor、To Survivor、Tenured ( 享有终身职位的 )。**进一步划分的目的是更好地回收内存，或者更快地分配内存。**

大部分情况，对象都会首先在 Eden 区域分配，在一次**新生代垃圾回收**后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加 1(Eden区->Survivor 区后对象的初始年龄变为1)，当它的年龄增加到一定程度（默认为15岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 `-XX:MaxTenuringThreshold` 来设置。



**方法区 / 永久代 / 元空间**

它用于存储**已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据**。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 **Non-Heap（非堆）**，目的应该是与 Java 堆区分开来。

补充: 方法区和永久代之间的关系

> 《Java虚拟机规范》只是规定了有方法区这么个概念和它的作用，并没有规定如何去实现它。那么，在不同的 JVM 上方法区的实现肯定是不同的了。 **方法区和永久代的关系很像Java中接口和类的关系，类实现了接口，而永久代就是HotSpot虚拟机对虚拟机规范中方法区的一种实现方式。** 也就是说，永久代是HotSpot的概念，方法区是Java虚拟机规范中的定义，是一种规范，而永久代是一种实现，

JDK 1.8 之前永久代还没被彻底移除的时候通常通过下面这些参数来调节方法区大小

> -XX:PermSize=N //方法区(永久代)初始大小 
>
> -XX:MaxPermSize=N //方法区(永久代)最大大小,超过这个值将会抛出OutOfMemoryError异常:java.lang.OutOfMemoryError: PermGen

JDK 1.8 的时候，方法区（HotSpot的永久代）被彻底移除了（JDK1.7就已经开始了），取而代之是元空间，**元空间使用的是直接内存**。与永久代很大的不同就是，如果不指定大小的话，随着更多类的创建，虚拟机会耗尽所有可用的系统内存。

> -XX:MetaspaceSize=N //设置Metaspace的初始（和最小大小）
>
> -XX:MaxMetaspaceSize=N //设置Metaspace的最大大小



**常量池**

运行时常量池是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池信息（用于存放编译期生成的各种字面量和符号引用）**JDK1.7及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。**

![image-20210125145959544](https://gitee.com/CTLQAQ/picgo/raw/master/image-20210125145959544.png)



### 

**直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 异常出现。**



### 内存溢出实战

使用一个链表（防止被GC回收掉）不断地向里面加入new XXObject(),会导致 **java堆内存溢出**。

一个方法自己调用自己，当深度过深地时。或者定义了大量的本地变量。会产生**StackOverflowError ,栈内存溢出**

jdk6中，可以使用String.intern()，方法不断向常量池中加入字符串常量，会导致永久代内存溢出。

**方法区溢出还有可能是因为，大量使用cglib增强，java动态代理，jsp等等。**

使用unsafe类或者使用DirectByteBuffer类，可能会导致直接内存溢出。



### JAVA对象创建过程

1. 类加载检查

2. 分配内存。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。**分配方式**有 **“指针碰撞”** 和 **“空闲列表”** 两种，**选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定**。

   > - 指针碰撞。用过的内存全部整合到一边，没有用过的内存放到另一边，中间有一个分界值指针，只要向着没有用过的内存方向将该指针移动对象内存大小即可。GC收集器：Serial , ParNew
   > - 空闲列表。虚拟机会维护一个列表，该列表会记录哪些内存块是可用的，在分配的时候，找一块足够大的内存块来划分给对象实例。

3. 初始化零值。这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。

4. 设置对象头。**虚拟机要对对象进行必要的设置**，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 **这些信息存放在对象头中**。

5. 执行init方法，初始化。。

### 对象的访问定位有哪2种方式

我们的Java程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式有虚拟机实现而定，目前主流的访问方式有**①使用句柄**和**②直接指针**两种：

1. **句柄：** 如果使用句柄的话，那么**Java堆中将会划分出一块内存来作为句柄池**，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息；

   ![image-20210220111724144](https://gitee.com/CTLQAQ/picgo/raw/master/image-20210220111724144.png)

2. **直接指针：** 如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference 中存储的直接就是对象的地址。

   ![image-20210220112609537](https://gitee.com/CTLQAQ/picgo/raw/master/image-20210220112609537.png)

3. **这两种对象访问方式各有优势。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。**

### 对象在堆中的内存布局

对象在堆内存中的存储部分分为三部分：对象头，实例数据，对齐填充

- 对象头一般包含2类信息
  - 对象自身的运行时数据（MarkWord）：HashCode，GC分代年龄，锁状态标志，线程持有的锁。（32位或64位）。会根据对象的状态复用自己的空间。
  - 类型指针。指向对象类型元数据的指针，通过这个指针确定该对象是哪个类的实例。
  - 例外：如果对象是一个java数组，那么对象头中还要记录数组的长度。
- 实例数据。对象真正存储的有效信息。
- 对齐填充。起到占位的作用。（任何对象大小都必须是8字节的整数倍）

### 简单聊一聊JVM垃圾回收

Java 堆是垃圾收集器管理的主要区域，因此也被称作**GC 堆（Garbage Collected Heap）**.从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代：再细致一点有：Eden 空间、From Survivor、To Survivor 空间等。**进一步划分的目的是更好地回收内存，或者更快地分配内存。**

大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加 1(Eden 区->Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 `-XX:MaxTenuringThreshold` 来设置。

> 修正（[issue552](https://github.com/Snailclimb/JavaGuide/issues/552)）：“Hotspot 遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了 survivor 区的一半时，取这个年龄和 MaxTenuringThreshold 中更小的一个值，作为新的晋升年龄阈值”。

### 堆内存中对象分配的基本策略

- 对象优先分配到eden区
- 大对象直接进入老年代
- 长期存活的对象将进入老年代

最简单的分代式GC策略，按照HotSpot VM的serialGC实现来看

- youngGC: 当eden区分配满的时候会触发。youngGC中有部分对象会晋升到oldgen。所以youngGC之后，老年代占用量通常会有所升高。
- full GC：当要准备触发一次YoungGC的时候，如果发现younggc晋升大小大于old gen剩余空间，则会转而触发full gc（整个堆上的gc）

**总结：**

针对 HotSpot VM 的实现，它里面的 GC 其实准确分类只有两大种：

部分收集 (Partial GC)：

- 新生代收集（Minor GC / Young GC）：只对新生代进行垃圾收集；
- 老年代收集（Major GC / Old GC）：只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集；
- 混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。

整堆收集 (Full GC)：收集整个 Java 堆和方法区。

### FULLGC触发条件

对于 Minor GC，其触发条件非常简单，当 Eden 空间满时，就将触发一次 Minor GC。

- 调用System.GC()只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存
- 老年代空间不足。老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等。为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组。
- 空间分配担保失败。使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC。



### 如何判断对象是否死亡

1. 引用计数法。给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加1；当引用失效，计数器就减1；任何时候计数器为0的对象就是不可能再被使用的。（缺点：很难解决对象之间相互引用的问题）

2. 可达性分析算法。通过一系列称为**"GC Roots"**的根对象作为起始节点集合，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”(Reference Chain)，如果某个对象到GC Roots间没有任何引用链相连，或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的。

   ![image-20210220121813828](https://gitee.com/CTLQAQ/picgo/raw/master/image-20210220121813828.png)

   可作为GC Roots的对象:（看下就行）

   1. 在虚拟机栈(栈帧中的本地变量表)中引用的对象。
   2. 在方法区中类静态属性引用的对象。
   3. 在方法区中常量引用的对象，如字符串常量池(String Table)里的引用指向的对象。
   4. 在本地方法栈中JNI (即通常所说的Native方法)引用的对象。
   5. Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象比如NullPointExcepiton、 OutOfMemoryError等，还有系统类加载器。
   6. 所有被同步锁(synchronized关键字) 持有的对象。
   7. 反映Java虚拟机内部情况的JMXBean，用于监管 JVM 和 JRE 的其他组件的 MBean、JVMTI，是Java虚拟机提供的一整套后门。通过这套后门可以对虚拟机方方面面进行监控，分析，在JVMTI中注册的回调、本地代码缓存等。
   8. 除了这些固定的GC Roots集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象"临时性”地加入，共同构成完整GC Roots集合。如，对某个区域（新生代GC）进行回收时，这个区域的对象可能会被堆中其他区域的对象引用。

   

   

### 介绍一下强引用，软引用，弱引用，虚引用

**在JDK 1.2版之后，Java对引用的概念进行了扩充，将引用分为**

- **强引用**是最传统的”引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似"Object obj=new Object()"这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。
- **软引用**是用来描述一些还有用，但非必须的对象。**软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收**，如果这次回收还没有足够的内存，才会抛出内存溢出异常。SoftReference类来实现软引用。SoftReference ss = new SoftReference<>("hello world");String rs = ss.get();
- **弱引用**也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，**被弱引用关联的对象只能生存到下一次垃圾收集发生为止**。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。WeakReference类来实现弱引用。
- **虚引用**也称为“幽灵引用”或者"幻影引用”，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。PhantomReference类来实现虚引用。



### 如何判断一个常量是废弃的常量

假如在常量池中存在字符串 "abc"，如果当前没有任何String对象引用该字符串常量的话，就说明常量 "abc" 就是废弃常量。

### 如何判断一个类是无用的类

类需要同时满足下面 3 个条件才能算是 **“无用的类”** ：

- 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。
- 加载该类的 `ClassLoader` 已经被回收。
- 该类对应的 `java.lang.Class` 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。





### 垃圾收集算法有那些？

**标记清除算法**

首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象，也可以反过来，标记存活的对象，统一回收所有未被标记的对象。

**主要缺点有两个:**

- **执行效率不稳定**,如果Java堆中包含大量对象，而且其中大部分是需要被回收的，这时必须进行大量标记和清除的动作，导致标记和清除两个过程的执行效率都随对象数量增长而降低;
- **内存空间的碎片化问题**，标记、清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存，而不得不提前触发另一次垃圾收集动作。

![image-20210220142325857](https://gitee.com/CTLQAQ/picgo/raw/master/image-20210220142325857.png)

**复制算法**

为了解决效率问题，“复制”收集算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。

![image-20210220142434852](https://gitee.com/CTLQAQ/picgo/raw/master/image-20210220142434852.png)

**标记整理(Mark-Compact)**

复制算法在对象存活率较高时就要进行较多的复制操作，效率将会降低。所以在老年代一般不能直接选用这种算法。针对老年代对象的存亡特征。

​		其中的标记过程仍然与”标记清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存。标记清除算法与标记整理算法的本质差异在于前者是一种非移动式的回收算法，而后者是移动式的。



### **HotSpot 为什么要分为新生代和老年代？**

当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将 java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。

**比如在新生代中，每次收集都会有大量对象死去，所以可以选择复制算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。**

### 常见的垃圾收集器有哪些？

![image-20210220143423846](https://gitee.com/CTLQAQ/picgo/raw/master/image-20210220143423846.png)

Serial（串行）收集器是最基本、历史最悠久的垃圾收集器了。它的 **“单线程”** 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ **"Stop The World"** ），直到它收集结束。**新生代采用复制算法，老年代采用标记-整理算法。**

![image-20210220144028974](https://gitee.com/CTLQAQ/picgo/raw/master/image-20210220144028974.png)

优点：**简单而高效（与其他收集器的单线程相比）**。Serial 收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率。Serial 收集器对于运行在 Client 模式下的虚拟机来说是个不错的选择。

**ParNew 收集器**

**ParNew 收集器其实就是 Serial 收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器完全一样。**

**新生代采用复制算法，老年代采用标记-整理算法。**

![image-20210220144203993](https://gitee.com/CTLQAQ/picgo/raw/master/image-20210220144203993.png)

**Parallel Scavenge 收集器**

Parallel Scavenge 收集器也是使用复制算法的多线程收集器，它看上去几乎和 ParNew 都一样。 **那么它有什么特别之处呢？**

**Parallel Scavenge 收集器关注点是吞吐量（高效率的利用 CPU）。CMS 等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是 CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值。** Parallel Scavenge 收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解，手工优化存在困难的时候，使用 Parallel Scavenge 收集器配合自适应调节策略，把内存管理优化交给虚拟机去完成也是一个不错的选择。

**新生代采用复制算法，老年代采用标记-整理算法。**



老年代收集器

Serial old收集器,**Serial 收集器的老年代版本**，它同样是一个单线程收集器。它主要有两大用途：一种用途是在 JDK1.5 以及以前的版本中与 Parallel Scavenge 收集器搭配使用，另一种用途是作为 CMS 收集器的后备方案。

**Parallel  Old** 收集器

**Parallel Scavenge 收集器的老年代版本**。使用多线程和“标记-整理”算法。在注重吞吐量以及 CPU 资源的场合，都可以优先考虑 Parallel Scavenge 收集器和 Parallel Old 收集器。



**CMS收集器  **    （**Concurrent Mark Sweep**）

CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。

CMS（Concurrent Mark Sweep）收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。

从名字中的**Mark Sweep**这两个词可以看出，CMS 收集器是一种 **“标记-清除”算法**实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：

- **初始标记：** 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；
- **并发标记：** 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。
- **重新标记：** 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短
- **并发清除：** 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。

![image-20210220145646419](https://gitee.com/CTLQAQ/picgo/raw/master/image-20210220145646419.png)

从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：**并发收集、低停顿**。但是它有下面三个明显的缺点：

- **对 CPU 资源敏感；**
- **无法处理浮动垃圾；**
- **它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。**



**Garbage First (简称G1)收集器**

开创了收集器面向局部收集的设计思路和基于Region的内存布局形式。G1是一款主要面向服务端应用的垃圾收集器。

G1收集器出现之前的所有其他收集器，包括CMS在内，垃圾收集的目标范围要么是整个新生代(MinorGC)， 要么就是整个老年代(MajorGC)， 再要么就是整个Java堆(Full GC)。而G1跳出了这个樊笼，它可以面向堆内存任何部分来组成回收集(Collection Set,一般简称CSet)进行回收，衡量标准不再是它属于哪个分代，而是哪块内存中存放的垃圾数量最多，回收收益最大，这就是G1收集器的Mixed GC模式。

G1的各代存储地址是不连续的，每一代都使用了n个不连续的大小相同的Region，每个Region占有一块连续的虚拟内存地址。

![image-20210220150355997](https://gitee.com/CTLQAQ/picgo/raw/master/image-20210220150355997.png)

每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间， 或者老年代空间。收集器能够对扮演不同角色的Region采用不同的策略去处理，这样无论是新创建的对象还是已经存活了一段时间、熬过多次收集的旧对象都能获取很好的收集效果。**Region中还有一类特殊的Humongous区域，专门用来存储大对象**。G1认为只要大小超过了一个Region容量一半的对象即可判定为大对象。每个Region的大小可以通过参数
**-XX: G1HeapRegionSize**设定，取值范围为1MB ~ 32MB，且应为2的N次幂。而对于那些超过了整个Region容量的超级大对象，将会被存放在N个连续的Humongous Region之中，G1的大多数行为都把Humongous Region作为老年代的一部分来进行看待。

G1收集器去跟踪各个Region里面的垃圾堆积的**“价值”**大小，**价值**即回收所获得的空间大小以及回收所需时间的经验值，然后在后台维护一个优先级列表，每次根据用户设定允许的收集停顿时间(**使用参数**
**-XX: MaxGCPauseMilis指定， 默认值是200毫秒**)，优先处理回收价值最大的那些Region,这也就是"Garbage First"名字的由来。这种使用Region划分内存空间，以及具有优先级的区域回收方式，**保证了G1收集器在有限的时间内获取尽可能高的收集效率。**



G1 收集器的运作大致分为以下几个步骤：

- **初始标记**
- **并发标记**
- **最终标记**
- **筛选回收**

### 



### String.intern()方法

是一个本地方法，它的作用是如果字符串常量池中已经包含一个等于此String对象的字符串，则返回代表池中这个字符串的String对象的引用；否则会把此String对象包含的字符串添加到常量池，并返回此String对象的引用。

JDK7之后，原本存放在永久代的字符串常量池被移动至java堆中。





## 类加载

### 类加载过程

![image-20210301091613712](https://gitee.com/CTLQAQ/picgo/raw/master/image-20210301091613712.png)

**加载**

主要完成下面3件事情：

1. 通过全类名获取定义此类的二进制字节流
2. 将字节流所代表的静态存储结构转换为方法区的运行时数据结构
3. 在内存中生成一个代表该类的 Class 对象,作为方法区这些数据的访问入口

"通过全类名获取定义此类的二进制字节流" 并没有指明具体从哪里获取、怎样获取。比如：比较常见的就是从 ZIP 包中读取（日后出现的JAR、EAR、WAR格式的基础）、其他文件生成（典型应用就是JSP）等等



**验证**

![image-20210312102046901](https://gitee.com/CTLQAQ/picgo/raw/master/image-20210312102046901.png)

**准备**

**准备阶段是正式为类变量分配内存并设置类变量初始值的阶段**，这些内存都将在方法区中分配。

这时候进行内存分配的仅包括类变量（static）

1. 这里所设置的初始值"通常情况"下是数据类型默认的零值（如0、0L、null、false等），比如我们定义了`public static int value=111` ，那么 value 变量在准备阶段的初始值就是 0 而不是111（初始化阶段才会赋值）。特殊情况：比如给 value 变量加上了 fianl 关键字`public static final int value=111` ，那么准备阶段 value 的值就被赋值为 111。

**初始化**

初始化是类加载的最后一步，也是真正执行类中定义的 Java 程序代码(字节码)，初始化阶段是执行初始化方法 `<clinit> ()`方法的过程。

对于`<clinit>（）` 方法的调用，虚拟机会自己确保其在多线程环境中的安全性。因为 `<clinit>（）` 方法是带锁线程安全，所以在多线程环境下进行类初始化的话可能会引起死锁，并且这种死锁很难被发现。



### 类初始化时机

主动引用

- 使用new实例化对象时，读取和设置类的静态变量、静态非字面值常量（静态字面值常量除外）时，调用静态方法时。
- 对类进行反射调用时。
- 当初始化一个类时，如果父类没有进行初始化，需要先初始化父类。
- 启动程序所使用的main方法所在类
- 当使用1.7的动态语音支持时。

被动引用

- 通过子类引用父类的静态字段，只会触发父类的初始化，而不会触发子类的初始化。
- 定义对象数组和集合，不会触发该类的初始化
- 类A引用类B的static final常量不会导致类B初始化（注意静态常量必须是字面值常量，否则还是会触发B的初始化）



## 类加载器

**类加载器并不需要等到某个类被“首次主动使用”时再加载它**

​	JVM规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了.class文件缺失或存在错误，类加载器必须在**程序首次主动**使用该类才报告错误（LinkageError错误），如果这个类没有被程序**主动使用**，那么类加载器就**不会**报告错误。

​	类加载器用来把类加载到java虚拟机中。从JDK1.2版本开始，类的加载过程采用父亲委托机制，这种机制能更好地保证Java平台的安全。在此委托机制中，除了java虚拟机自带的根类加载器以外，其余的类加载器都有且只有一个父加载器。当java程序请求加载器loader1加载Sample类时，loader1首先委托自己的父加载器去加载Sample类，若父加载器能加载，则由父加载器完成加载任务，否则才由加载器loader1本身加载Sample类。

1. Java虚拟机自带的加载器
   - **根类加载器**（Bootstrap）：该加载器没有父加载器，它负责加载虚拟机中的核心类库，如java.lang.* 。根类加载器从系统属性sun.boot.class.path所指定的目录中加载类库。类加载器的实现依赖于底层操作系统，属于虚拟机的实现的一部分，它并没有继承java.lang.ClassLoader类。
   - **扩展类加载器**（Extension）：它的父加载器为根类加载器。它从java.ext.dirs系统属性所指定的目录中加载类库，或者从JDK的安装目录的jre\lib\ext子目录（扩展目录）下加载类库，如果把用户创建的jar文件放在这个目录下，也会自动由扩展类加载器加载，扩展类加载器是纯java类，是java.lang.ClassLoader的子类。
   - **系统应用类加载器**（System）：也称为应用类加载器，它的父加载器为扩展类加载器，它从环境变量classpath或者系统属性java.class.path所指定的目录中加载类，他是用户自定义的类加载器的默认父加载器。系统类加载器时纯java类，是java.lang.ClassLoader的子类。
2. 用户自定义的类加载器
   - java.lang.ClassLoader的子类 
   - 用户可以定制类的加载方式



### 双亲委派模型

每一个类都有一个对应它的类加载器。系统中的 ClassLoder 在协同工作的时候会默认使用 **双亲委派模型** 。即在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。加载的时候，首先会把该请求委派该父类加载器的 `loadClass()` 处理，因此所有的请求最终都应该传送到顶层的启动类加载器 `BootstrapClassLoader` 中。当父类加载器无法处理时，才由自己来处理。当父类加载器为null时，会使用启动类加载器 `BootstrapClassLoader` 作为父类加载器。

如果不想用双亲委托机制

**自定义加载器的话，需要继承 `ClassLoader` 。如果我们不想打破双亲委派模型，就重写 `ClassLoader` 类中的 `findClass()` 方法即可，无法被父类加载器加载的类最终会通过这个方法被加载。但是，如果想打破双亲委派模型则需要重写 `loadClass()` 方法**



### 命名空间

- 每个类加载器都有自己的命名空间，**命名空间由该加载器及所有父加载器所加载的类构成**；
- 在同一个命名空间中，不会出现类的完整名字（包括类的包名）相同的两个类；
- 在不同的命名空间中，有可能会出现类的完整名字（包括类的包名）相同的两个类；
- 同一命名空间内的类是互相可见的，**非同一命名空间内的类是不可见的**；
- 子加载器可以见到父加载器加载的类，**但是父加载器不能见到子加载器加载的类**。





### 类加载器双亲委托模型的好处

- 可以确保Java和核心库的安全：所有的Java应用都会引用java.lang中的类，也就是说在运行期java.lang中的类会被加载到虚拟机中，如果这个加载过程如果是由自己的类加载器所加载，那么很可能就会在JVM中存在多个版本的java.lang中的类，而且这些类是相互不可见的（命名空间的作用）。借助于双亲委托机制，Java核心类库中的类的加载工作都是由启动根加载器去加载，从而确保了Java应用所使用的的都是同一个版本的Java核心类库，他们之间是相互兼容的；
- 确保Java核心类库中的类不会被自定义的类所替代；
- 不同的类加载器可以为相同名称的类（binary name）创建额外的命名空间。相同名称的类可以并存在Java虚拟机中，只需要用不同的类加载器去加载即可。相当于在Java虚拟机内部建立了一个又一个相互隔离的Java类空间。





# 读书笔记

## 第三章 垃圾收集与内存分配策略

### 对象生存还是死亡

被判定位不可达的对象也不一定会马上被收集，如果这个对象覆盖了finalize(), 方法，且虚拟机没有调用该finalize方法，则会将其放到一个优先级很低的队列F-Queue，里面去执行他们的finalize方法。在finalize() 方法中，它可以被自救（例如，将this赋值给当前类的一个静态变量）。**但是这种自救只有一次机会，因为一个对象的finalize() 方法，最多被执行一次。**

:< 不推荐使用

### 分代收集理论（经验论）

1. 弱分代假说。绝大多数对象都是朝生夕灭的。
2. 强分代假说。熬过越多次垃圾收集过程的对象就越难以消亡。
3. 跨代引用假说。跨代引用相对于同代引用来说仅占极少数。00



# 参考

https://snailclimb.gitee.io/javaguide

深入理解java虚拟机