<html>
  <head>
	  <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>i5ting_ztree_toc:mysql面试题</title>
		<link href="toc/style/github-bf51422f4bb36427d391e4b75a1daa083c2d840e.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/style/github2-d731afd4f624c99a4b19ad69f3083cd6d02b81d5.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/zTreeStyle/zTreeStyle.css" media="all" rel="stylesheet" type="text/css"/>
	  <style>
		pre {
		    counter-reset: line-numbering;
		    border: solid 1px #d9d9d9;
		    border-radius: 0;
		    background: #fff;
		    padding: 0;
		    line-height: 23px;
		    margin-bottom: 30px;
		    white-space: pre;
		    overflow-x: auto;
		    word-break: inherit;
		    word-wrap: inherit;
		}

		pre a::before {
		  content: counter(line-numbering);
		  counter-increment: line-numbering;
		  padding-right: 1em; /* space after numbers */
		  width: 25px;
		  text-align: right;
		  opacity: 0.7;
		  display: inline-block;
		  color: #aaa;
		  background: #eee;
		  margin-right: 16px;
		  padding: 2px 10px;
		  font-size: 13px;
		  -webkit-touch-callout: none;
		  -webkit-user-select: none;
		  -khtml-user-select: none;
		  -moz-user-select: none;
		  -ms-user-select: none;
		  user-select: none;
		}

		pre a:first-of-type::before {
		  padding-top: 10px;
		}

		pre a:last-of-type::before {
		  padding-bottom: 10px;
		}

		pre a:only-of-type::before {
		  padding: 10px;
		}

		.highlight { background-color: #ffffcc } /* RIGHT */
		</style>
  </head>
  <body>
	  <div>
				<div style='width:25%;'>
						<ul id="tree" class="ztree" style='width:100%'>

						</ul>
				</div>
        <div id='readme' style='width:70%;margin-left:20%;'>
          	<article class='markdown-body'>
            	<p><a href="https://blog.csdn.net/m0_45270667/article/details/108950184">https://blog.csdn.net/m0_45270667/article/details/108950184</a></p>
<p><a href="https://mp.weixin.qq.com/s/pC0_Y7M7BkoUmlRwneZZdA">https://mp.weixin.qq.com/s/pC0_Y7M7BkoUmlRwneZZdA</a></p>
<h4 id="-myisam-innodb-">能说下myisam 和 innodb的区别吗？</h4>
<ul>
<li><p>InnoDB支持事务，MyISAM不支持。对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务；</p>
</li>
<li><p>InnoDB支持外键，而MyISAM不支持。对一个包含外键的InnoDB表转为MYISAM会失败；</p>
</li>
<li><p>InnoDB是聚集索引，数据文件是和索引绑在一起的，必须要有主键，通过主键索引效率很高。</p>
<p>但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此主键不应该过大，因为主键太大，其他索引也都会很大。</p>
<p>而MyISAM是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。</p>
</li>
<li><p>InnoDB不保存表的具体行数，执行select count(*) from table时需要全表扫描。而MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；</p>
</li>
<li><p>Innodb不支持全文索引，而MyISAM支持全文索引，查询效率上MyISAM要高；</p>
</li>
</ul>
<p><strong>如何选择：</strong></p>
<ul>
<li>是否要支持事务，如果要请选择innodb，如果不需要可以考虑MyISAM；</li>
<li>如果表中绝大多数都只是读查询，可以考虑MyISAM，如果既有读写也挺频繁，请使用InnoDB</li>
<li>系统奔溃后，MyISAM恢复起来更困难，能否接受；</li>
<li>MySQL5.5版本开始Innodb已经成为Mysql的默认引擎(之前是MyISAM)，说明其优势是有目共睹的，如果你不知道用什么，那就用InnoDB，至少不会差。</li>
</ul>
<p>innodb B+Tree实现如下：</p>
<p><img src="https://gitee.com/CTLQAQ/picgo/raw/master/image-20210225204008766.png" alt="image-20210225204008766"></p>
<p>myisam </p>
<p><img src="https://gitee.com/CTLQAQ/picgo/raw/master/image-20210225204033382.png" alt="image-20210225204033382"></p>
<h4 id="-mysql-">说下mysql的索引有哪些吧，聚簇和非聚簇索引又是什么？</h4>
<p>索引按照数据结构来说主要包含B+树和Hash索引。</p>
<p>数据和索引在一起存储的索引方式叫做聚簇索引，一张表只能有一个聚簇索引。假设没有定义主键，InnoDB会选择一个唯一的非空索引代替，如果没有的话则会隐式定义一个主键作为聚簇索引。</p>
<p>非聚簇索引(二级索引)保存的是主键id值，这一点和myisam保存的是数据地址是不同的。</p>
<h4 id="-innodb-">为什么InnoDB表必须有主键？并且推荐使用整形的自增主键？</h4>
<p>是因为这样可以使插入一条数据永远为最后一条数据（如果使用的是varchar类型的作为主键，则新插入一条数据，有可能是在中间插入，可能会增加分裂次数，增加维护开销），在叶子链表的最后，<strong>减少b+树分裂的次数</strong>，这样就降低了维护代价</p>
<h4 id="-">为什么使用数据索引能提高效率</h4>
<ol>
<li>数据索引的存储是有序的</li>
<li>在有序的情况下，通过索引查询一个数据是无需遍历索引记录的</li>
<li>极端情况下，数据索引的查询效率为二分法查询效率，趋近于 log2(N)</li>
</ol>
<h4 id="b-">B+树索引和哈希索引的区别</h4>
<p>B+树是一个平衡的多叉树，从根节点到每个叶子节点的高度差值不超过1，而且同层级的节点间有指针相互链接，是有序的</p>
<p><img src="https://gitee.com/CTLQAQ/picgo/raw/master/image-20210225215916084.png" alt="image-20210225215916084"></p>
<p>哈希索引就是采用一定的哈希算法，把键值换算成新的哈希值，检索时不需要类似B+树那样从根节点到叶子节点逐级查找，只需一次哈希算法即可,是无序的</p>
<p><img src="https://gitee.com/CTLQAQ/picgo/raw/master/image-20210225215954874.png" alt="image-20210225215954874"></p>
<p><strong>等值查询，</strong>哈希索引具有绝对优势（前提是：没有大量重复键值，如果大量重复键值时，哈希索引的效率很低，因为存在所谓的哈希碰撞问题。）</p>
<h4 id="-">哈希索引不适用的场景</h4>
<ol>
<li>不支持范围查询</li>
<li>不支持索引完成排序</li>
<li>不支持联合索引的最左前缀匹配规则</li>
</ol>
<h4 id="b-b-">B树和B+树的区别</h4>
<p>B树，每个节点都存储key和data，所有节点组成这棵树，并且叶子节点指针为nul，叶子结点不包含任何关键字信息。</p>
<p><img src="https://gitee.com/CTLQAQ/picgo/raw/master/image-20210225220430492.png" alt="image-20210225220430492"></p>
<p>B+树，所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大的顺序链接</p>
<h4 id="-b-b-">为什么说B+比B树更适合实际应用中操作系统的文件索引和数据库索引？</h4>
<ul>
<li>B+的磁盘读写代价更低。B+的内部结点(非叶子节点)并没有指向关键字具体信息的指针，因此其内部结点相对B树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。</li>
<li>B+-tree的查询效率更加稳定。由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</li>
</ul>
<h4 id="-">联合索引</h4>
<p>联合索引是两个或更多个列上的索引。对于联合索引:Mysql从左到右的使用索引中的字段，一个查询可以只使用索引中的一部份，但只能是最左侧部分。（最左前缀原则）</p>
<h4 id="-"><strong>什么情况下应不建或少建索引</strong></h4>
<p>1、表记录太少</p>
<p>2、经常插入、删除、修改的表</p>
<p>3、数据重复且分布平均的表字段，假如一个表有10万行记录，有一个字段A只有T和F两种值，且每个值的分布概率大约为50%，那么对这种表A字段建索引一般不会提高数据库的查询速度。</p>
<p>4、经常和主字段一块查询但主字段索引值比较多的表字段</p>
<h4 id="-">为什么非主键索引结构的叶子节点存储的是主键值？</h4>
<p>为了一致性（个人理解：防止当增加一条数据时，需要在多个索引结构中进行多数据的添加）。节省存储空间。</p>
<p><img src="https://gitee.com/CTLQAQ/picgo/raw/master/image-20210225203430998.png" alt="image-20210225203430998"></p>
<h4 id="-">锁的类型</h4>
<p>mysql锁分为共享锁和排他锁，也叫做读锁和写锁。</p>
<p>读锁是共享的，可以通过lock in share mode实现，这时候只能读不能写。</p>
<p>写锁是排他的，它会阻塞其他的写锁和读锁。从颗粒度来区分，可以分为表锁和行锁两种。</p>
<p>表锁会锁定整张表并且阻塞其他用户对该表的所有读写操作，比如alter修改表结构的时候会锁表。</p>
<p>行锁又可以分为乐观锁和悲观锁，悲观锁可以通过for update实现，乐观锁则通过版本号实现。</p>
<h4 id="-acid">事务的基本特性ACID</h4>
<p>A=Atomicity。原子性,就是上面说的,要么全部成功,要么全部失败.不可能只执行一部分操作.</p>
<p>C=Consistency。系统(数据库)总是从一个一致性的状态转移到另一个一致性的状态,不会存在中间状态.</p>
<p>I=Isolation。隔离性: 通常来说:一个事务在完全提交之前,对其他事务是不可见的.注意前面的通常来说加了红色,意味着有例外情况.</p>
<p>D=Durability。持久性,一旦事务提交,那么就永远是这样子了,哪怕系统崩溃也不会影响到这个事务的结果.</p>
<h4 id="-">事务的隔离级别</h4>
<p>read uncommit 读未提交，可能会读到其他事务未提交的数据，也叫做脏读。用户本来应该读取到id=1的用户age应该是10，结果读取到了其他事务还没有提交的事务，结果读取结果age=20，这就是脏读。</p>
<p><img src="https://gitee.com/CTLQAQ/picgo/raw/master/image-20210225205205434.png" alt="image-20210225205205434"></p>
<p>read commit 读已提交，两次读取结果不一致，叫做不可重复读。不可重复读解决了脏读的问题，他只会读取已经提交的事务。</p>
<p>用户开启事务读取id=1用户，查询到age=10，再次读取发现结果=20，在同一个事务里同一个查询读取到不同的结果叫做不可重复读。</p>
<p><img src="https://gitee.com/CTLQAQ/picgo/raw/master/image-20210225205301885.png" alt="image-20210225205301885"></p>
<p>repeatable read 可重复复读，这是mysql的默认级别，就是每次读取结果都一样，但是有可能产生幻读。</p>
<p>幻读：在一个事务中使用相同的 SQL 两次读取，第二次读取到了其他事务新插入的行。</p>
<p><img src="https://gitee.com/CTLQAQ/picgo/raw/master/image-20210225205938442.png" alt="image-20210225205938442"></p>
<p>小明开启事务current_version=6查询名字为’王五’的记录，发现不存在。
小红开启事务current_version=7插入一条数据，结果是这样：</p>
<p>小明执行插入名字’王五’的记录，发现唯一索引冲突，无法插入，这就是幻读。</p>
<p>serializable 串行，一般是不会使用的，他会给每一行读取的数据加锁，会导致大量超时和锁竞争的问题。</p>
<h4 id="acid-">ACID靠什么保障？</h4>
<p>A原子性由undo log日志保证，它记录了需要回滚的日志信息，事务回滚时撤销已经执行成功的sql</p>
<p>C一致性一般由代码层面来保证</p>
<p>I隔离性由MVCC来保证</p>
<p>D持久性由内存+redo log来保证，mysql修改数据同时在内存和redo log记录这次操作，事务提交的时候通过redo log刷盘，宕机的时候可以从redo log恢复</p>
<h4 id="-mvcc-">那你说说什么是幻读，什么是MVCC？</h4>
<p><a href="https://blog.csdn.net/xvshu/article/details/88085598">https://blog.csdn.net/xvshu/article/details/88085598</a></p>
<p>MVCC (Multi-Version Concurrency Control) (注：与MVCC相对的，是基于锁的并发控制，Lock-Based Concurrency Control)是一种基于多版本的并发控制协议，只有在InnoDB引擎下存在。MVCC是为了实现事务的隔离性，通过版本号，避免同一数据在不同事务间的竞争，你可以把它当成基于多版本号的一种乐观锁。当然，这种乐观锁只在事务级别未提交锁和已提交锁时才会生效。MVCC最大的好处，相信也是耳熟能详：读不加锁，读写不冲突。在读多写少的OLTP应用中，读写不冲突是非常重要的，极大的增加了系统的并发性能。具体见下面介绍。</p>
<p>mysql的innodb采用的是行锁，而且采用了多版本并发控制来提高读操作的性能。什么是多版本并发控制呢 ？<strong>其实就是在每一行记录的后面增加两个隐藏列，记录创建版本号和删除版本号，而每一个事务在启动的时候，都有一个唯一的递增的版本号。</strong> </p>
<p>于是乎，默认的隔离级别（REPEATABLE READ）下，增删查改变成了这样：</p>
<p> INSERT ：   将当前事务的版本号保存到行的创建版本号。比如我插入一条记录, 事务id 假设是1 ，那么记录如下：也就是说，创建版本号就是事务版本号。</p>
<p><img src="https://gitee.com/CTLQAQ/picgo/raw/master/image-20210225213209928.png" alt="image-20210225213209928"></p>
<p>UPDATE : 新插入一行，并以当前事务的版本号作为新行的创建版本号，同时将原记录行的删除版本号设置为当前事务版本号。</p>
<p>在更新操作的时候，采用的是先标记旧的那行记录为已删除，并且删除版本号是事务版本号，然后插入一行新的记录的方式。 比如，针对上面那行记录，事务Id为2 要把name字段更新。</p>
<p><img src="https://gitee.com/CTLQAQ/picgo/raw/master/image-20210225213349224.png" alt="image-20210225213349224"></p>
<p>DELETE：将当前事务的版本号保存至行的删除版本号</p>
<p>删除操作的时候，就把事务版本号作为删除版本号。比如：</p>
<p><img src="https://gitee.com/CTLQAQ/picgo/raw/master/image-20210225213431782.png" alt="image-20210225213431782"></p>
<p>查询操作：从上面的描述可以看到，在查询时要符合以下两个条件的记录才能被事务查询出来： </p>
<ul>
<li><p>删除版本号 大于 当前事务版本号，就是说删除操作是在当前事务启动之后做的。 </p>
</li>
<li><p>创建版本号 小于或者等于 当前事务版本号 ，就是说记录创建是在事务中（等于的情况）或者事务启动之前。</p>
</li>
</ul>
<p>这样就保证了各个事务互不影响。从这里也可以体会到一种提高系统性能的思路，就是：通过版本号来减少锁的争用。另外，只有read-committed和 repeatable-read 两种事务隔离级别才能使用mVcc read-uncommited由于是读到未提交的，所以不存在版本的问题。而serializable 则会对所有读取的行加锁。 </p>
<h4 id="-mvcc-2-">在MVCC并发控制中，读操作可以分为2类</h4>
<ol>
<li><strong>快照读 (snapshot read)</strong>：读取的是记录的可见版本 (有可能是历史版本)，不用加锁（共享读锁s锁也不加，所以不会阻塞其他事务的写）</li>
<li><strong>当前读 (current read)</strong>：读取的是记录的最新版本，并且，当前读返回的记录，都会加上锁，保证其他事务不会再并发修改这条记录</li>
<li>普通的SELECT就是快照读，而UPDATE、DELETE、INSERT、SELECT …  LOCK IN SHARE MODE、SELECT … FOR UPDATE是当前读。</li>
</ol>
<h4 id="-">数据模型的分解</h4>
<p><strong>对关系模式进行必要的分解，提高数据的操作效率和存储空间利用率。</strong></p>
<p>水平分解</p>
<p> 水平分解是把关系的元组分为若干子集合，定义每个子集合的为一个子关系，以提高系统的效率。根据“80/20原则”，一个大关系中，经常被使用的数据只占一部分，约20%，可以把经常使用的数据分解出来，形成一个子关系。如果关系R上有n个事务，且事务存取数据 不相交，则可以使每个事务对应一个关系。</p>
<p>垂直分解</p>
<p> 垂直分解是把关系模式R的属性分解为若干子集合，形成若干子关系模式。垂直分解的原则是将经常在一起使用的属性从R中分解出来形成一个子关系模式。垂直分解可以提高某些事务的效率，但也可能使另外一些事务不得不执行连接操作。</p>
<h4 id="-id-">分表之后如何保证ID的唯一性</h4>
<p>因为我们主键默认都是自增的，那么分表之后的主键在不同表就肯定会有冲突了。有几个办法考虑：</p>
<ol>
<li>设定步长，比如1-1024张表我们分别设定1-1024的基础步长，这样主键落到不同的表就不会冲突了。</li>
<li>分布式ID，自己实现一套分布式ID生成算法或者使用开源的比如雪花算法这种。</li>
<li>分表后不使用主键作为查询依据，而是每张表单独新增一个字段作为唯一主键使用，比如订单表订单号是唯一的，不管最终落在哪张表都基于订单号作为查询依据，更新也一样。</li>
</ol>

          	</article>
        </div>
		</div>
  </body>
</html>
<script type="text/javascript" src="toc/js/jquery-1.4.4.min.js"></script>
<script type="text/javascript" src="toc/js/jquery.ztree.all-3.5.min.js"></script>
<script type="text/javascript" src="toc/js/ztree_toc.js"></script>
<script type="text/javascript" src="toc_conf.js"></script>

<SCRIPT type="text/javascript" >
<!--
$(document).ready(function(){
    var css_conf = eval(markdown_panel_style);
    $('#readme').css(css_conf)
    
    var conf = eval(jquery_ztree_toc_opts);
		$('#tree').ztree_toc(conf);
});
//-->
</SCRIPT>