# 1 基础

## 位运算

**^ 可以看作是无进位相加** 如

```
100011 ^
011010 =
111001
```

^ 满足交换律和结合律： a^b = b ^ a

例题

数组中只有1个数出现了奇数次，其他都出现偶数次，求这个出现奇数次的数。

> 答：所有数都异或存入num变量中

有2个数出现了奇数次，其他数出现了偶数次，求这两个数。

> 答：所有数异或得到num=a^b， 然后mask = num & (-num) 得到一位1。创建2个变量num1, num2, 对于所有的arr[i], 如果arr[i] & mask == 0 , num1 ^= arr[i] 。nums2 = num ^ num1。最后num1, num2即为所求。



## Master公式

www.gocalf.com/blog/algorithm-complexity-and-master-theorem.html  

对于子问题等规模的问题，可以使用master求解时间复杂度

> T(N) = a*T(N/b) + O(N^d)
> 1) log(b,a) > d -> 复杂度为O(N^log(b,a))
> 2) log(b,a) = d -> 复杂度为O(N^d * logN)
> 3) log(b,a) < d -> 复杂度为O(N^d)  

看下面2个栗子

![image-20210320235259457](https://gitee.com/CTLQAQ/picgo/raw/master/image-20210320235259457.png)

> 对于上述代码，process里面分成2个子问题而且都是等规模N/2，剩下的操作时间复杂度为O(N^0) (O(1)),
>
> 所以 T(N) = 2 * T(N/2) + O(N^0)
>
> log(b,a) = log(2,2) = 1 > d, 所以时间复杂度为O(N^log(b,a)) = O(N)



![image-20210320235931665](https://gitee.com/CTLQAQ/picgo/raw/master/image-20210320235931665.png)

> 此时  T(N) = 2 * T(N/2) + O(N^1)
>
> log(b,a) = log(2,2) = 1 = d, 所以复杂度为O(N^d * logN)=O(N*logN)





## 排序

### 归并排序

#### 逆序对问题

在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。

[7,5,6,4]  这个数组中共有5个逆序对，75 76 76 54 64

> 这个问题可以使用归并排序来解决假设数组 
>
> ```java
> l1   r1
> 2  4  6
> i
> l2   r2
> 1  2  3  7
> j
> 首先2 > 1所以 j ++ ,2 <= 2, i++ 此时，2的逆序对求完了，个数为j-l2+1 =1。
> 然后4 > 2 j ++, 4 > 3 j ++, 4<= 7 i ++，此时4 的逆序对求完了个数为 j-l2+1=3
> ```

 

```java
public class 逆序个数 {
	@Test
	public void test(){
	    reversePairs(new int[]{7,5,6,4});//5
	}
	public int reversePairs(int[] nums) {
		return mergeSort(nums, 0, nums.length - 1, new int[nums.length]);
	}

	int mergeSort(int[] arr, int l, int r, int[] temp) {
		if (l >= r) {
			return 0;
		}
		int mid = (l + r) / 2;
		return mergeSort(arr, l, mid, temp)
				+ mergeSort(arr, mid + 1, r, temp)
				+ partation(arr, l, mid, mid + 1, r, temp);
	}

	int partation(int[] arr, int l1, int r1, int l2, int r2, int[] temp) {
		int res = 0;

		int i = l1, j = l2, index = 0;
		while (i <= r1 && j <= r2) {
			//要求arr[i]的逆序对, 此时j左边的都是小于arr[i]的元素，都可以组成逆序对
			//这里必须有等于
			if (arr[i] <= arr[j]) {
				//此时除了arr[j] 前面的数都是可以和i构成逆序对的
				res += j - l2;
				temp[index ++] = arr[i ++];
			}else {
				//此时并不能确定逆序对有多少个
				temp[index ++] = arr[j ++];
			}
		}
		while (i <= r1){
			//能进入这个里面，说明j=r2 + 1,但是i还没有求完，所以
			res += j - l2;
			temp[index ++] = arr[i ++];
		}
		while (j <= r2){
			temp[index ++] = arr[j ++];
		}
		for (int k = 0; k < index; k++) {
			arr[l1 + k] = temp[k];
		}
		return res;
	}
}
```



### 快速排序

#### 荷兰国旗问题

给定一个数组arr， 和一个数num， 请把小于num的数放在数组的 左边， 等于num的数放在数组的中间， 大于num的数放在数组的右边，并返回，num对应下标，要求额外空间复杂度O(1)， 时间复杂度O(N) 

例如 [1 2 9 6 5 5]  应该变为：[* * 5 5 * *]

```java
public class 荷兰国旗问题 {
	int[] partation(int[] arr, int l, int r, int num) {
		int left = l - 1; //小于num的左边界左边元素
		int right = r + 1;// 大于num的右边界右边元素
		int i = l;
		while (i < right) {
			//应该放右边
			if (arr[i] > num) {
				swap(arr, i , --right);
			} else if (arr[i] < num) {
                //从左边换过来的是已经判断过的元素，所以i++
				swap(arr, i++, ++left);
			} else {
				i++;
			}
		}
		return new int[]{left + 1, right - 1};
	}

	void swap(int[] arr, int i, int j) {
		int temp = arr[i];
		arr[i] = arr[j];
		arr[j] = temp;
	}

	@Test
	public void test() {
		int[] a = partation(new int[]{1, 2, 9, 6, 5, 5}, 0, 5, 5);
	}
}
```

