# 言

## 按值传递和按引用传递的区别

**The Java Spec says that everything in Java is pass-by-value. There is no such thing as “pass-by-reference” in Java.**官方的说法是在java中只有按值传递，并没有所谓的按引用传递。java数据类型可以分为两大类：基本类型（primitive types）和引用类型（reference types）

![image-20210124151337933](https://gitee.com/CTLQAQ/picgo/raw/master/image-20210124151337933.png)

对于基本数据类型：

举个栗子：swap(int x, int y);

当swap函数中对x，y交换时只是对swap帧中的x，y做交换，并不会改变main中的x，y。所以当函数返回时main中的x，y并不会改变。**对于基本数据类型：按值传递调用函数并不会改变在原函数中的值。**

**引用类型的按值传递，传递的是对象的地址**



## 面向对象的三大特性的理解

**封装**给对象提供了隐藏内部特性和行为的能力。 

**多态**性是允许你将父对象设置成为一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。父对象就可以根据实际类型来表先不同的行为。

**继承**提供了代码的重用性，也可以在不修改类的情况下给现存的类添加新特性。 



## == 和 equals 的区别

==：对于基本类型，它比较的是值，对于引用类型，它比较的是内存地址。

equals()的作用也是比较两个对象是否相等，但它一般有2种使用情况：

- 类如果没有覆盖equals()方法，则通过equals() 比较的的时候等价于“==”
- 第二种情况是我们可以自定义equals()的内容，判断两个对象的内容是否相等，例如对于People对象来说，如果其身份证号码相等我们就认为它是相等的。



## 类的 hashcode 是什么

**1)hashCode()介绍:**

`hashCode()` 的作用是获取哈希码，也称为散列码；它实际上是返回一个 int 整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。`hashCode()`定义在 JDK 的 `Object` 类中，这就意味着 Java 中的任何类都包含有 `hashCode()` 函数。另外需要注意的是： `Object` 的 hashcode 方法是本地方法，也就是用 c 语言或 c++ 实现的，该方法通常用来将对象的内存地址 转换为整数之后返回。

**2)为什么要有 hashCode？**

因为在使用散列的时候，我们可以快速定位对象的位置。当你把对象加入 `HashSet` 时，`HashSet` 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的 hashcode，`HashSet` 会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 `equals()` 方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，`HashSet` 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。

**3)为什么重写 `equals` 时必须重写 `hashCode` 方法？**

如果两个对象相等，则 hashcode 一定也是相同的。两个对象相等,对两个对象分别调用 equals 方法都返回 true。**但是，两个对象有相同的 hashcode 值，它们也不一定是相等的。因此，equals 方法被覆盖过，则 `hashCode` 方法也必须被覆盖。**



## 如果两个对象的 hash 码相同，equals 一定为 true 吗

不一定，因为 `hashCode()` 所使用的杂凑算法也许刚好会让多个对象传回相同的杂凑值。就是碰撞。

自己的总结，

hash算法是自己书写的，可能会发生碰撞，判断2个对象是否相等，可以先判断2个对象的hashcode 是否相等，如果两个对象的hashcode不相等，则肯定不是同一个对象。如果相等，则需要使用equals() 判断。所以说，如果覆盖equals方法，一定要覆盖hashcode，否则，两个equals相等的对象的hashcode也会不一样（因为Object 里面的hashCode 使用的是native方法，是根据内存地址转换成正数得来的），这样在使用某些集合框架的时候可能会造成错误。

在Hahset种，有了hashcode可以减少通常比较耗时的equals方法。 



## 什么是泛型

**Java泛型设计原则：只要在编译时期没有出现警告，那么运行时期就不会出现ClassCastException异常**.

泛型：**把类型明确的工作推迟到创建对象或调用方法的时候才去明确的特殊的类型**

- `ArrayList<E>`中的**E称为类型参数变量**
- `ArrayList<Integer>`中的**Integer称为实际类型参数**

再没有泛型之前，集合框架是使用Object实现的，在集合种读取到的每一个对象都需要进行强制类型转化，如果不小心插入了类型错误的对象，只有在运行的时候才会发现错误。有了泛型之后，可以告诉编译器，每个集合种接收那些对象类型，并再编译时告知是否插入了错误的对象。

## 介绍一下JAVA内存区域

1.8 之前

![image-20210125142015747](https://gitee.com/CTLQAQ/picgo/raw/master/image-20210125142015747.png)

1.8 

![image-20210125142426115](https://gitee.com/CTLQAQ/picgo/raw/master/image-20210125142426115.png)

**线程私有的：**

- 程序计数器
- 虚拟机栈
- 本地方法栈

**线程共享的：**

- 堆
- 方法区
- 直接内存(非运行时数据区的一部分)

### 线程私有

#### 程序计数器

程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。**字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完。**

另外，**为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。**

主要作用：

- 字节码解释器通过改变程序计数器来依次读取指令，从而**实现代码的流程控制**，如：顺序执行、选择、循环、异常处理。
- 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。

**程序计数器是唯一一个不会出现 OutOfMemoryError 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。**



#### Java虚拟机栈

Java虚拟机栈也是线程私有的，它的**生命周期和线程相同**，**描述的是 Java 方法执行的内存模型**，每次方法调用的数据都是通过栈传递的。

Java 内存可以粗糙的区分为堆内存（Heap）和栈内存(Stack),其中栈就是现在说的虚拟机栈，或者说是虚拟机栈中局部变量表部分。（实际上，Java虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息。）

**局部变量表主要存放了编译器可知的各种数据类型**（boolean、byte、char、short、int、float、long、double）、**对象引用**（reference类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。

**Java 虚拟机栈会出现两种异常：StackOverFlowError 和 OutOfMemoryError。**

- **StackOverFlowError：** 若Java虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前Java虚拟机栈的最大深度的时候，就抛出StackOve	rFlowError异常。
- **OutOfMemoryError：** 若 Java 虚拟机栈的内存大小允许动态扩展，且当线程请求栈时内存用完了，无法再动态扩展了，此时抛出OutOfMemoryError异常。

**那么方法/函数如何调用？**

Java 栈中保存的主要内容是栈帧，每一次函数调用都会有一个对应的栈帧被压入Java栈，每一个函数调用结束后，都会有一个栈帧被弹出。

Java方法有两种返回方式：

1. return 语句。
2. 抛出异常。

不管哪种返回方式都会导致栈帧被弹出

#### 本地方法栈

和虚拟机栈所发挥的作用非常相似，区别是： **虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。** 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。

本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 StackOverFlowError 和 OutOfMemoryError 两种异常。

### 线程共享

#### 堆	

Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。**此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。**

Java 堆是垃圾收集器管理的主要区域，因此也被称作**GC堆（Garbage Collected Heap）**.从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以Java堆还可以细分为：新生代和老年代：再细致一点有：Eden空间、From Survivor、To Survivor、Tenured ( 享有终身职位的 )。**进一步划分的目的是更好地回收内存，或者更快地分配内存。**

大部分情况，对象都会首先在 Eden 区域分配，在一次**新生代垃圾回收**后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加 1(Eden区->Survivor 区后对象的初始年龄变为1)，当它的年龄增加到一定程度（默认为15岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 `-XX:MaxTenuringThreshold` 来设置。

#### 方法区 / 永久代 / 元空间

它用于存储**已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据**。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 **Non-Heap（非堆）**，目的应该是与 Java 堆区分开来。

补充: 方法区和永久代之间的关系

> 《Java虚拟机规范》只是规定了有方法区这么个概念和它的作用，并没有规定如何去实现它。那么，在不同的 JVM 上方法区的实现肯定是不同的了。 **方法区和永久代的关系很像Java中接口和类的关系，类实现了接口，而永久代就是HotSpot虚拟机对虚拟机规范中方法区的一种实现方式。** 也就是说，永久代是HotSpot的概念，方法区是Java虚拟机规范中的定义，是一种规范，而永久代是一种实现，一个是标准一个是实现，其他的虚拟机实现并没有永久代这一说法。

JDK 1.8 之前永久代还没被彻底移除的时候通常通过下面这些参数来调节方法区大小

> -XX:PermSize=N //方法区(永久代)初始大小 
>
> -XX:MaxPermSize=N //方法区(永久代)最大大小,超过这个值将会抛出OutOfMemoryError异常:java.lang.OutOfMemoryError: PermGen

JDK 1.8 的时候，方法区（HotSpot的永久代）被彻底移除了（JDK1.7就已经开始了），取而代之是元空间，**元空间使用的是直接内存**。与永久代很大的不同就是，如果不指定大小的话，随着更多类的创建，虚拟机会耗尽所有可用的系统内存。

> -XX:MetaspaceSize=N //设置Metaspace的初始（和最小大小）
>
>  -XX:MaxMetaspaceSize=N //设置Metaspace的最大大小

#### 运行时常量池

运行时常量池是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池信息（用于存放编译期生成的各种字面量和符号引用）**JDK1.7及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。**

![image-20210125145959544](https://gitee.com/CTLQAQ/picgo/raw/master/image-20210125145959544.png)

### 直接内存

**直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 异常出现。**





## 什么是 NIO

**NIO（Non-Blocking I/O,java中,也称为New I/O），是一种同步非阻塞的I/O模型**

NIO采用内存映射文件的方式来处理输入输出，NIO将文件或文件的一段区域映射到内存中，这样就可以像访问内存一样访问文件了。NIO与原来的IO有同样的作用和目的，但是使用的方式完全不同， NIO支持面向缓冲区(Buffer)的、基于通道(Channel)的IO操作。NIO将以更加高效的方式进行文件的读写操作。

NIO中的三个重要组件：

**1. 缓冲区Buffer**

在NIO库中，所有数据都是用缓冲区处理的。在读取数据时，它是直接读到缓冲区中的； 在写入数据时，它也是写入到缓冲区中的。

**2. 通道Channel**

Channel和传统IO中的Stream很相似。主要区别为：**通道是双向的，通过一个Channel既可以进行读，也可以进行写；而Stream只能进行单向操作，通过一个Stream只能进行读或者写，比如InputStream只能进行读取操作，OutputStream只能进行写操作；**通道是一个对象，通过它可以读取和写入数据，当然了所有数据都通过Buffer对象来处理。我们永远不会将字节直接写入通道中，相反是将数据写入包含一个或者多个字节的缓冲区。同样不会直接从通道中读取字节，而是将数据从通道读入缓冲区，再从缓冲区获取这个字节。

**3.选择器Selector**

Selector类是NIO的核心类，Selector（选择器）选择器提供了选择已经就绪的任务的能力。**Selector会不断的轮询注册在上面的所有channel，如果某个channel为读写等事件做好准备，那么就处于就绪状态，通过Selector可以不断轮询发现出就绪的channel，进行后续的IO操作。**一个Selector能够同时轮询多个channel。这样，一个单独的线程就可以管理多个channel，从而管理多个网络连接。这样就不用为每一个连接都创建一个线程，同时也避免了多线程之间上下文切换导致的开销。

## *** BIO、NIO、AIO 概念和区别

### BIO

BIO又被称为阻塞式I/O模型。客户端有连接请求时服务器端就需要启动一个线程进行处理，处理完成后返回应答给客户端，也就是经典的请求－应答通信模型。但是随着客户端并发量上升，服务端的线程数膨胀，系统性能急剧下降，最终会导致系统不可用。这种模型无法满足高并发，高性能的场景。



## jdk 中线程池的类型

**在什么情况下使用线程池？**

  1.单个任务处理的时间比较短
  2.将需处理的任务的数量大

**实现线程池的好处，总结以下几点：**

- 1.降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。
- 2.提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。
- 3.提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。

线程池的创建可以通过创建 ThreadPoolExecutor 对象或者调用 Executors 的工厂方法来创建线程池。

### 使用 Executors 的工厂方法创建线程

- newCachedThreadPool：

  创建一个可缓存线程池

  优点：很灵活，弹性的线程池线程管理，用多少线程给多大的线程池，不用后及时回收，用则新建

  缺点：一旦线程无限增长，会导致内存溢出。

- newFixedThreadPool ：

  优点：创建一个固定大小线程池，超出的线程会在队列中等待。

  缺点：不支持自定义拒绝策略，大小固定，难以扩展

- newScheduledThreadPool ：

  优点：创建一个固定大小线程池，可以定时或周期性的执行任务。

  缺点：任务是单线程方式执行，一旦一个任务失败其他任务也受影响

- newSingleThreadExecutor ：

  优点：创建一个单线程的线程池，保证线程的顺序执行

  缺点：不适合并发。。

- **统一缺点：**不支持自定义拒绝策略

Executors 返回的线程池对象的弊端如下： 

1） FixedThreadPool 和 SingleThreadPool: 

允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。 

2） CachedThreadPool 和 ScheduledThreadPool: 

允许的创建线程数量为 Integer.MAX_VALUE， 可能会创建大量的线程，从而导致 OOM。

## 线程池的 BlockQueue 的作用

BlockingQueue 
一个阻塞队列，**用来存储等待执行的任务**，常用的有如下几种：
**ArrayBlockingQueue**：是一个基于数组结构的有界阻塞队列，此队列按 FIFO（先进先出）原则对元素进行排序。
**LinkedBlockingQueue**：一个基于链表结构的阻塞队列，此队列按FIFO （先进先出） 排序元素，吞吐量通常要高于	
**ArrayBlockingQueue**。静态工厂方法Executors.newFixedThreadPool()使用了这个队列。
**SynchronousQueue**：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQueue，静态工厂方法Executors.newCachedThreadPool使用了这个队列。
**PriorityBlockingQueue**：一个具有优先级得无限阻塞队列。



如果阻塞队列满了，需要用到拒绝策略

RejectedExecutionHandler : 当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。有下面四种JDK提供的策略：
**AbortPolicy**，表示无法处理新任务时抛出异常, 默认策略
**CallerRunsPolicy**：用调用者所在线程来运行任务。
**DiscardOldestPolicy**： 该策略将丢弃最老的一个请求，也就是丢弃即将被执行的任务，并尝试再次提交当前任务。
**DiscardPolicy**：不处理，丢弃掉 
除了这些JDK提供的策略外，还可以自己实现 RejectedExecutionHandler 接口定义策略。

## Java 怎么保证多线程的安全

1. 使用volatile( 不稳定的、反复无常的)，或者 synchronized关键字解决内存可见性问题。
2. 可以使用锁机制，synchronized，和CAS来解决原子性问题
3. 可以使用信号量机制解决同步问题。

### 内存可见性

先看如下代码：

```java
public class TestVolatile {
    public static void main(String[] args) {
        ThreadDemo td = new ThreadDemo();
        new Thread(td).start();
        while(true){
            if(td.isFlag()){
                System.out.println("--------主线中的程序读到flag为true了----------");
                break;
            }
//这里不能有语句，有语句循环之间就有间隙
        }
    }
}

class ThreadDemo implements Runnable {
    private boolean flag = false;
    //private volatile boolean flag = false; 加上volatile之后，程序可以正常终止
    @Override
    public void run() {
        try {
            Thread.sleep(200);
        } catch (InterruptedException e) {
        }
        flag = true;
        System.out.println("flag=" + isFlag());
    }
    public boolean isFlag() {
        return flag;
    }
    public void setFlag(boolean flag) {
        this.flag = flag;
    }
}
```

上面的线程永远不会停止 

**内存可见性其实就是共享变量在线程间的可见性**

- **共享变量**：如果一个变量在多个线程的工作内存中都存在**副本**，那么这个变量就是这几个线程的共享变量
- **可见性**：一个线程对共享变量值的修改，能够及时的被其他线程看到

**Java内存模型**

- 所有的变量都存储在主内存中（**操作系统给进程分配的内存空间**）

- **每个线程都有自己独立的工作内存，里面保存该线程使用到的变量的副本**

![image-20210126160641338](https://gitee.com/CTLQAQ/picgo/raw/master/image-20210126160641338.png)

主内存中存在flag = false，线程td启动后，将flag = false，放到自己的工作内存中，然后睡眠1秒，这期间，（因为要使用）主线程也把flag = false放到自己的工作内存放到自己的工作空间。td线程把flag = true由刷新到主内存中，但是主线程工作空间内的flag还是false。也就是说，td对共享变量的修改对主线程“不可见了”

**特别注意**：

- 线程对共享变量的所有操作都必须在自己的工作内存（working memory,是cache和寄存器的一个抽象，而并不是内存中的某个部分）**不同线程之间，当前线程无法直接访问其他线程的工作内存中的变量，线程间变量值得传递需要通过主内存来完成**

**共享变量可见性的实现原理**

- **把工作内存1中更新过的共享变量刷新到主内存中**
- **将主内存中最新的共享变量的值更新到工作内存2中**

#### 解决办法

使用volatile之后，td将更改刷到主存中后，会告知main线程

使用**synchronized**

JMM关于synchronized的两条规定：

- **线程解锁前，必须把共享变量的最新值刷新到主内存中**

- **线程加锁时，将清空工作内存中共享变量的值，从而使用共享变量时需要从主内存中重新读取最新的值** 

```java
synchronized (td){
                if(td.isFlag()){
                   break;
               }
            }
```

**synchronized和volatile比较**

- volatile不需要加锁，比synchronized更轻量级，不会阻塞线程，效率更高

- volatile不具备“互斥性”，synchronized就具备“互斥性”

  - 何为互斥性？

    比方说当我们用synchronize修饰方法，

    当一个线程抢到锁执行该方法后另一个线程无法再抢到锁执行该方法

- synchronized既能保证可见性，又能保证原子性，而volatile只能保证可见性，不能保证原子性。

- 如果能用volatile解决问题，还是应尽量使用volatile，因为它的效率更高 

### 原子性

经典不具有原子性的操作,包括读取变量的原始值、进行加1操作、写入工作内存

```java
 public int getSerialNumber(){
    return serialNumber++;
}
```

**JUC这个工具包里，有一个包含原子变量子包，**java.util.concurrent.atomic，

里边封装了一系列常用的数据类型对应的封装类，

Java.util.concurrent.atomic中实现的原子操作类包括：

AtomicBoolean、AtomicInteger、AtomicLong、AtomicReference。

**这些类都保证了两点：**

- **类里的变量都用了volatile保证内存是可见的**
- 使用了一个算法**CAS**，保证对这些数据的操作具有原子性

#### CAS （Compare and Swap）算法逻辑的理解 

- **悲观锁：传统的锁机制**，例如 java 的 synchronized 关键字，他代表了 java 中悲观锁技术，保证了某一时刻仅有一个线程能访问同步代码/方法。synchronized 能够很好地工作，却有着 (相对) 比较大的性能开销。
- **乐观锁** (相对悲观锁) 对性能会有很大的帮助。他的核心思想是：寄希望于在没有冲突的情况下完成一次更新操作，使用乐观锁技术更新时会进行 “冲突检测” 来判断是否有其他的线程干扰，若是 (有其他线程干扰) 则视本次更新操作失败，一般会进行重试。
- Compare and Swap 就是典型的乐观锁技术

**CAS是通过硬件命令保证了原子性 ** CAS有3个操作数，**内存值V，旧的预期值A，要修改的新值B**。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则返回V。

就是指当V和A两者进行比较时，如果相等，则证明共享数据没有被修改，替换成新值，然后继续往下运行；如果不相等，说明共享数据已经被修改，放弃已经所做的操作，然后重新执行刚才的操作。这样子，就能保证操作的原子性了。

![image-20210126162533637](https://gitee.com/CTLQAQ/picgo/raw/master/image-20210126162533637.png)



例如：t1，t2线程是同时更新同一变量56的值。因为t1和t2线程都同时去访问同一变量值56，所以他们会把主内存的值完全拷贝一份到自己的工作内存空间，所以t1和t2线程的预期值都为56。假设此时t1 竞争到了CPU，t1的旧的预期值为56 与内存值56相等，于是它可以把共享变量修改成57。 此时t2 又竞争到了CPU，t2的预期值与主内存中的不一样，所以他就要放弃此次修改，然后重试。

### 线程按序交替ABC

编写一个程序，开启三个线程，这三个线程的ID分别为A、B、C，每个线程将自己的ID在屏幕上打印10遍，要求输出的结果必须按顺序显示，如:ABCABCABC……

方法1：使用信号量机制

```java
public class ABCThread {
	public static void main(String[] args) {
		Semaphore printA = new Semaphore(1);
		Semaphore printB = new Semaphore(0);
		Semaphore printC = new Semaphore(0);
		new Thread(()->{
			for(int i = 0; i < 10; i ++){
				try {
					printA.acquire();
					System.out.println("A");
					printB.release();
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
			}
		}).start();
		new Thread(()->{
			for(int i = 0; i < 10; i ++){
				try {
					printB.acquire();
					System.out.println("B");
					printC.release();
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
			}
		}).start();
		new Thread(()->{
			for(int i = 0; i < 10; i ++){
				try {
					printC.acquire();
					System.out.println("C");
					printA.release();
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
			}
		}).start();
	}
}
```

### volatile synschonized 的区别和运用场景

**synchronized和volatile比较**

- volatile不需要加锁，比synchronized更轻量级，不会阻塞线程，效率更高

- volatile不具备“互斥性”，synchronized就具备“互斥性”

  - 何为互斥性？

    比方说当我们用synchronize修饰方法，

    当一个线程抢到锁执行该方法后另一个线程无法再抢到锁执行该方法

- synchronized既能保证可见性，又能保证原子性，而volatile只能保证可见性，不能保证原子性。

- 如果能用volatile解决问题，还是应尽量使用volatile，因为它的效率更高 

Synchronized 的底层实现
Java 反射是什么，反射的用处
JVM 内存区域划分
java 怎么和数据库交互
静态代理的实现方式
AQS 的实现原理
c++ 和 java 的区别
有哪些 jdk 调优工具
GC 垃圾回收算法
分代回收算法
栈帧中包含哪些内容
lambda 函数实现机理
有哪些设计模式
Java 深拷贝浅拷贝，深拷贝如何去做
Java 锁机制，lock 实现
Java 里面如何去关闭一个线程
Java 线程池的原理和实现，一些机制

# 框架

Spring 怎么解决循环依赖
Spring 怎么解析 xml
Spring 的 AOP原理
事务的传播机制有哪些，分别应用于哪些场景
Bean 的生命周期
beanFactory 和 factoryBean
SpringCloud 的负载均衡
SpringCloud 的心跳机制
Springboot 的自动配置
怎么用线程做一个熔断器
计算机网络
OSI 七层模型
三次握手和四次挥手
TCP、UDP属于哪个层
TCP 和 UDP 得区别
FTP 在哪个层
TCP 如何保证可靠传输的
哪些情况下可以使用 udp
拥塞控制和流量控制
session 和 cookie 的区别
tcp 连接过程中 syn_sent 连接数过多会是什么原因造成的
什么是长连接短连接
如何拦截 http 请求

# 数据结构

Java 中集合都有哪些
集合之间的区别，使用的数据结构的区别，应用场景？
1000 万个数据的 B+ 树有多高
什么是跳表
HashMap 得原理，是线程安全的么？如果需要线程安全怎么办
二叉搜索树，二叉平衡树，红黑树的区别
阻塞队列的实现方式
Conurrentmap 的实现方式，为什么是线程安全的
Arrays.sort() 底层
哈夫曼树原理

# 数据库

什么是覆盖索引
什么是最左匹配原则
数据库中得连接方式有哪些
什么是数据库事务
什么是 ACID
什么是 MVCC
Mysql 事务实现的底层原理
Mysql 如何查看你的 sql 执行情况
什么是 sql 注入
redis 数据库一致性的解决方案
有哪些数据库中间件
慢查询的解决方式
数据库的隔离级别
为什么会出现幻读
间隙锁怎么实现的
char 和 varchar 的区别

# 操作系统

线程与进程区别
线程有哪些调度机制
多线程是什么，为什么需要多线程，什么情况下需要多线程
有几种创建线程的方法
进程有哪些状态
死锁的条件
select、poll、epoll 得区别
跑程序时候发现服务器系统内存占用 100% 怎么办
进程间通讯方式
CAS 的缺点是什么，怎么解决 ABA 问题
僵尸进程和孤儿进程
悲观锁和乐观锁

# 算法

快排和选择排序的复杂度和最坏情况
堆排的排序思路和过程
环形链表
环形链表 II
寻找重复数
连续子数组的最大和
对一个大文件的数据进行排序，内存肯定放不下，怎么办
正则表达式匹配
合并k个升序链表
两个栈实现队列

