



# 操作系统

## 基础知识

### 死锁产生的四个必要条件

1. 互斥条件：进程要求对所分配的资源进行排它性控制，即在一段时间内某资源仅为一进程所占用。
2. 请求和保持条件：当进程因请求资源而阻塞时，对已获得的资源保持不放。
3. 不剥夺条件：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放。
4. 循环等待：在发生死锁时，必然存在一个进程--资源的环形链。

### 预防死锁的基本方法

- 资源一次性分配：一次性分配所有资源，这样就不会再有请求了：（破坏请求条件）
- 只要有一个资源得不到分配，也不给这个进程分配其他的资源：（破坏请保持条件）
- 可剥夺资源：即当某进程获得了部分资源，但得不到其它资源，则释放已占有的资源（破坏不可剥夺条件）
- 资源有序分配法：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏环路等待条件）

### 避免死锁

银行家算法，获取一个安全序列（按照这个序列进行进程推进可以避免死锁）。系统资源数，当前各个进程资源数。

### 内存管理机制

分为**连续分配管理方式**和**非连续分配管理方式**。

**连续分配**

1. 单一连续分配。只能用于单用户、单任务的操作系统中。
2. 固定分区分配。把内存分为一些大小相等或不等的分区(partition)，每个应用进程占用一个分区。操作系统占用其中一个分区。
3. 动态分区分配。分区的大小不固定：在装入程序时根据进程实际需要，动态分配内存空间，即——需要多少划分多少。会维护一个空闲分区链表。

分区分配算法：

1. 首次适应算法FF(first-fit)。空闲分区排序：以地址递增的次序链接。分配内存时，从链首开始顺序查找直至找到一个大小能满足要求的空闲分区；
2. 循环首次适应算法。从上次找到的空闲分区的下一个空闲分区开始查找，直到找到一个能满足要求的空闲分区。为实现算法，需要设置一个起始查寻指针并采用循环查找方式
3. 最佳适应算法。空闲分区排序：所有空闲分区按容量从小到大排序成空闲分区表或链。总是把能满足要求、又是最小的空闲分区分配给作业，避免“大材小用”。
4. 最差适应算法/最坏匹配法。基本不留下小空闲分区，但会出现缺乏较大的空闲分区的情况。

内存空间回收的时候注意区间合并的问题。

**非连续分配**

https://www.cnblogs.com/caidi/p/6724639.html

- 基本分页存储管理。**固定分区会产生内部碎片，动态分区会产生外部碎片**，这两种技术对内存的利用率都比较低。我们希望内存的使用能尽量避免碎片的产生，这就引入了分页的思想：把主存空间划分为大小相等且固定的块，块相对较小，作为主存的基本单位。每个进程也以块为单位进行划分，进程在执行时，以块为单位逐个申请主存中的块空间。**地址结构包含两部分：前一部分为页号P，后一部分为页内偏移量W**。页面大小应该适中，如果页面太小，会使进程的页面数过多，这样页表就过长，占用大量内存，而且也会增加硬件地址转换的开销，降低页面换入/换出的效率；页面过大又会使页内碎片增大，降低内存的利用率。所以页面的大小应该适中，考虑到空间效率和时间效率的权衡。
- 基本分段存储管理方式。段式管理方式按照用户进程中的自然段划分逻辑空间。例如，用户进程由主程序、两个子程序、栈和一段数据组成，于是可以把这个用户进程划分为5个段，每段从0开始编址，并分配一段连续的地址空间（**段内要求连续，段间不要求连续，因此整个作业的地址空间是二维的**）。其逻辑地址由段号S与段内偏移量W两部分组成。
- 段页式存储管理。 **在段页式存储管理系统中，作业的地址空间首先被分成若干个逻辑分段，每段都有自己的段号，然后再将每段分成若干个大小相等的页。对于主存空间也分成大小相等的页，主存的分配以页为单位。** 段页式系统中，作业的地址结构包含三部分的内容：段号、页号、页内位移量





### **什么是操作系统？**

1. **操作系统（Operating System，简称 OS）是管理计算机硬件与软件资源的程序，是计算机的基石。**
2. **操作系统的内核（Kernel）是操作系统的核心部分，它负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理**。 内核是连接应用程序和硬件的桥梁，决定着系统的性能和稳定性。

### 什么是系统调用？

我们运行的程序基本都是运行在用户态，如果我们调用操作系统提供的系统态级别的子功能咋办呢？那就需要系统调用了！也就是说在我们运行的用户程序中，凡是与系统态级别的资源有关的操作（如文件管理、进程控制、内存管理等)，都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成。

这些系统调用按功能大致可分为如下几类：

- 设备管理。完成设备的请求或释放，以及设备启动等功能。
- 文件管理。完成文件的读、写、创建及删除等功能。
- 进程控制。完成进程的创建、撤销、阻塞及唤醒等功能。
- 进程通信。完成进程之间的消息传递或信号传递等功能。
- 内存管理。完成内存的分配、回收以及获取作业占用内存区大小及地址等功能。

### 进程有哪几种状态

我们一般把进程大致分为 5 种状态

- **创建状态(new)** ：进程正在被创建，尚未到就绪状态。
- **就绪状态(ready)** ：进程已处于准备运行状态，即进程获得了除了处理器之外的一切所需资源，一旦得到处理器资源(处理器分配的时间片)即可运行。
- **运行状态(running)** ：进程正在处理器上上运行(单核 CPU 下任意时刻只有一个进程处于运行状态)。
- **阻塞状态(waiting)** ：又称为等待状态，进程正在等待某一事件而暂停运行如等待某资源为可用或等待 IO 操作完成。即使处理器空闲，该进程也不能运行。
- **结束状态(terminated)** ：进程正在从系统中消失。可能是进程正常结束或其他原因中断退出运行。

### 进程间通信

进程之间要交换数据必须通过内核，在内核中开辟一块缓冲区，进程1把数据从用户空间拷到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为**进程间通信（IPC，InterProcess Communication）**

- 匿名管道。用于具有亲缘关系的父子进程间或者兄弟进程之间的通信。
- **有名管道(Names Pipes)** : 匿名管道由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道。有名管道严格遵循**先进先出(first in first out)**。有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。
- **信号(Signal)** ：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生；
- **消息队列(Message Queuing)** ：消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识。管道和消息队列的通信数据都是先进先出的原则。与管道（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）不同的是消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显示地删除一个消息队列时，该消息队列才会被真正的删除。消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取.比 FIFO 更有优势。**消息队列克服了信号承载信息量少，管道只能承载无格式字 节流以及缓冲区大小受限等缺。**
- **信号量(Semaphores)** ：信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信方式主要用于解决与同步相关的问题并避免竞争条件。
- **共享内存(Shared memory)** ：使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。可以说这是最有用的进程间通信方式。
- **套接字(Sockets)** : 此方法主要用于在客户端和服务器之间通过网络进行通信。套接字是支持 TCP/IP 的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。

### **线程间的同步的方式有哪些呢?**

1. **互斥量(Mutex)**：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。比如 Java 中的 synchronized 关键词和各种 Lock 都是这种机制。
2. **信号量(Semphares)** ：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量
3. **事件(Event)** :Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操

### 进程的调度算法

# 数据库

## mysql

### MyISAM和InnoDB的区别

MyISAM是MySQL的默认数据库引擎（5.5版之前）。虽然性能极佳，而且提供了大量的特性，包括全文索引、压缩、空间函数等，但MyISAM不支持事务和行级锁，而且最大的缺陷就是崩溃后无法安全恢复。不过，5.5版本之后，MySQL引入了InnoDB（事务性数据库引擎），MySQL 5.5版本后默认的存储引擎为InnoDB。

大多数时候我们使用的都是 InnoDB 存储引擎，但是在某些情况下使用 MyISAM 也是合适的比如读密集的情况下。（如果你不介意 MyISAM 崩溃恢复问题的话）。

对比：

1. **是否支持行级锁** : MyISAM 只有表级锁(table-level locking)，而InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁。
2. **是否支持事务和崩溃后的安全恢复： MyISAM** 强调的是性能，每次查询具有原子性,其执行速度比InnoDB类型更快，但是不提供事务支持。但是**InnoDB** 提供事务支持事务，外部键等高级数据库功能。 具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。
3. **是否支持外键：** MyISAM不支持，而InnoDB支持。
4. **是否支持MVCC** ：仅 InnoDB 支持。应对高并发事务, MVCC比单纯的加锁更高效;MVCC只在 `READ COMMITTED` 和 `REPEATABLE READ` 两个隔离级别下工作;MVCC可以使用 乐观(optimistic)锁 和 悲观(pessimistic)锁来实现;各数据库中MVCC实现并不统一。





# JAVA语言

## 语言细节

### 按值传递和按引用传递的区别

官方的说法是在**java中只有按值传递，并没有所谓的按引用传递**。java数据类型可以分为两大类：基本类型（primitive types）和引用类型（reference types）。**引用类型的按值传递，传递的是对象的地址**

![image-20210124151337933](https://gitee.com/CTLQAQ/picgo/raw/master/image-20210124151337933.png)



### 面向对象的三大特性的理解

**封装**给对象提供了隐藏内部特性和行为的能力。 

**多态**性是允许你将父对象设置成为一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。父对象就可以根据实际类型来表先不同的行为。

**继承**提供了代码的重用性，也可以在不修改类的情况下给现存的类添加新特性。 

### JAVA异常

在 Java 中，所有的异常都有一个共同的祖先 `java.lang` 包中的 `Throwable` 类。`Throwable` 类有两个重要的子类 `Exception`（异常）和 `Error`（错误）。`Exception` 能被程序本身处理(`try-catch`)， `Error` 是无法处理的(只能尽量避免)。

### Java 序列化中如果有些字段不想进行序列化，怎么办？

对于不想进行序列化的变量，使用 transient 关键字修饰。

transient 关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被 transient 修饰的变量值不会被持久化和恢复。transient 只能修饰变量，不能修饰类和方法。

### 深拷贝VS浅拷贝

1. **浅拷贝**：对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝，此为浅拷贝。
2. **深拷贝**：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，此为深拷贝。



### == 和 equals 的区别

==：对于基本类型，它比较的是值，对于引用类型，它比较的是内存地址。

equals()的作用也是比较两个对象是否相等，但它一般有2种使用情况：

- 类如果没有覆盖equals()方法，则通过equals() 比较的的时候等价于“==”
- 第二种情况是我们可以自定义equals()的内容，判断两个对象的内容是否相等，例如对于People对象来说，如果其身份证号码相等我们就认为它是相等的。



### 类的 hashcode 是什么

**1)hashCode()介绍:**

`hashCode()` 的作用是获取哈希码，也称为散列码；它实际上是返回一个 int 整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。`hashCode()`定义在 JDK 的 `Object` 类中，这就意味着 Java 中的任何类都包含有 `hashCode()` 函数。另外需要注意的是： `Object` 的 hashcode 方法是本地方法，也就是用 c 语言或 c++ 实现的，该方法通常用来将对象的内存地址 转换为整数之后返回。

**2)为什么要有 hashCode？**

**因为在使用散列的时候，我们可以快速定位对象的位置**。当你把对象加入 `HashSet` 时，`HashSet` 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的 hashcode，`HashSet` 会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 `equals()` 方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，`HashSet` 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。



### 为什么重写 `equals` 时必须重写 `hashCode` 方法？

如果两个对象相等，则 hashcode 一定也是相同的。两个对象相等,对两个对象分别调用 equals 方法都返回 true。**但是，两个对象有相同的 hashcode 值，它们也不一定是相等的。因此，equals 方法被覆盖过，则 `hashCode` 方法也必须被覆盖。**否则，两个equals相等的对象的hashcode也会不一样（因为Object 里面的hashCode 使用的是native方法，是根据内存地址转换成正数得来的），这样在使用某些集合框架的时候可能会造成错误。



### 什么是泛型？

**Java泛型设计原则：只要在编译时期没有出现警告，那么运行时期就不会出现ClassCastException异常**.

泛型：**把类型明确的工作推迟到创建对象或调用方法的时候才去明确的特殊的类型**

- `ArrayList<E>`中的**E称为类型参数变量**
- `ArrayList<Integer>`中的**Integer称为实际类型参数**

没有泛型之前，集合框架是使用Object实现的，在集合种读取到的每一个对象都需要进行强制类型转化，如果不小心插入了类型错误的对象，只有在运行的时候才会发现错误。有了泛型之后，可以告诉编译器，每个集合种接收那些对象类型，并再编译时告知是否插入了错误的对象。



### c++ 和 java 的区别

- 都是面向对象的语言，都支持封装、继承和多态
- Java 不提供指针来直接访问内存，程序内存更加安全
- Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。
- Java 有自动内存管理机制，不需要程序员手动释放无用内存
- **在 C 语言中，字符串或字符数组最后都会有一个额外的字符‘\0’来表示结束。但是，Java 语言中没有结束符这一概念。**因为java中String是个对象，有长度的概念，已经不需要'\0'表示结尾

### 重载和重写的区别

**重载：**

发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。

**重写：**

重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。

1. 返回值类型、方法名、参数列表必须相同，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。
2. 如果父类方法访问修饰符为 `private/final/static` 则子类就不能重写该方法，但是被 static 修饰的方法能够被再次声明。
3. 构造方法无法被重写



### 为什么String是不可变的？

**可变性**

简单的来说：String 类中使用 final 关键字修饰字符数组来保存字符串，`private final char value[]`，所以 String 对象是不可变的。

> 补充（来自[issue 675](https://github.com/Snailclimb/JavaGuide/issues/675)）：在 Java 9 之后，String 类的实现改用 byte 数组存储字符串 `private final byte[] value`

### StringBuffer和StringBuilder的区别是什么？

StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串`char[]value` 但是没有用 final 关键字修饰，所以这两种对象都是可变的。

**线程安全性**

StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。

**性能**

相同情况下使用 StringBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。



## 集合框架

### HashMap 和 Hashtable 有什么区别？

HashMap 和 Hashtable 都实现了 Map 接口，因此很多特性非常相似。

不同点：

 1，HashMap 允许键和值是 null，key为null`的键值对永远都放在以`table`[0]为头结点的链表中。`而 Hashtable 不允许键或者值是 null。

2,Hashtable 是线程安全的，而 HashMap 不是，多线程环境下可以采用concurrent并发包下的concurrentHashMap。因此，HashMap 更适合于单线程环境，而 Hashtable 适合于多线程环境。



### HashSet 和 TreeSet 有什么区别？

HashSet 是由一个 hash 表来实现的，因此，它的元素是无序的。add()，remove()，contains() 方法的时间复杂度是 O(1)。

TreeSet 是由一个树形的结构来实现的，它里面的元素是有序的。因此，add()， remove()，contains()方法的时间复杂度是 O(logn)。



## JVM

### 介绍一下JAVA内存区域

1.8 之前

![image-20210125142015747](https://gitee.com/CTLQAQ/picgo/raw/master/image-20210125142015747.png)

1.8 

![image-20210125142426115](https://gitee.com/CTLQAQ/picgo/raw/master/image-20210125142426115.png)

**线程私有的：**

- 程序计数器
- 虚拟机栈
- 本地方法栈

**线程共享的：**

- 堆
- 方法区
- 直接内存(非运行时数据区的一部分)



**程序计数器**

程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。**字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完。**

主要作用：

- 实现代码的流程控制
- 现场恢复

**程序计数器是唯一一个不会出现 OutOfMemoryError 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。**



**Java虚拟机栈**

Java虚拟机栈也是线程私有的，它的**生命周期和线程相同**，**描述的是 Java 方法执行的内存模型**，每次方法调用的数据都是通过栈传递的。Java虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息。

**局部变量表主要存放了编译器可知的各种数据类型**（boolean、byte、char、short、int、float、long、double）、**对象引用**（reference类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。

**Java 虚拟机栈会出现两种异常：StackOverFlowError 和 OutOfMemoryError。**

**那么方法/函数如何调用？**

Java 栈中保存的主要内容是栈帧，每一次函数调用都会有一个对应的栈帧被压入Java栈，每一个函数调用结束后，都会有一个栈帧被弹出。

Java方法有两种返回方式：

1. return 语句。
2. 抛出异常。

不管哪种返回方式都会导致栈帧被弹出



**本地方法栈**

和虚拟机栈所发挥的作用非常相似，区别是： **虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。** 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。



**堆**	

ava 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。**此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。**

Java 堆是垃圾收集器管理的主要区域，因此也被称作**GC堆（Garbage Collected Heap）**.从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以Java堆还可以细分为：新生代和老年代：再细致一点有：Eden空间、From Survivor、To Survivor、Tenured ( 享有终身职位的 )。**进一步划分的目的是更好地回收内存，或者更快地分配内存。**

大部分情况，对象都会首先在 Eden 区域分配，在一次**新生代垃圾回收**后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加 1(Eden区->Survivor 区后对象的初始年龄变为1)，当它的年龄增加到一定程度（默认为15岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 `-XX:MaxTenuringThreshold` 来设置。



**方法区 / 永久代 / 元空间**

它用于存储**已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据**。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 **Non-Heap（非堆）**，目的应该是与 Java 堆区分开来。

补充: 方法区和永久代之间的关系

> 《Java虚拟机规范》只是规定了有方法区这么个概念和它的作用，并没有规定如何去实现它。那么，在不同的 JVM 上方法区的实现肯定是不同的了。 **方法区和永久代的关系很像Java中接口和类的关系，类实现了接口，而永久代就是HotSpot虚拟机对虚拟机规范中方法区的一种实现方式。** 也就是说，永久代是HotSpot的概念，方法区是Java虚拟机规范中的定义，是一种规范，而永久代是一种实现，

JDK 1.8 之前永久代还没被彻底移除的时候通常通过下面这些参数来调节方法区大小

> -XX:PermSize=N //方法区(永久代)初始大小 
>
> -XX:MaxPermSize=N //方法区(永久代)最大大小,超过这个值将会抛出OutOfMemoryError异常:java.lang.OutOfMemoryError: PermGen

JDK 1.8 的时候，方法区（HotSpot的永久代）被彻底移除了（JDK1.7就已经开始了），取而代之是元空间，**元空间使用的是直接内存**。与永久代很大的不同就是，如果不指定大小的话，随着更多类的创建，虚拟机会耗尽所有可用的系统内存。

> -XX:MetaspaceSize=N //设置Metaspace的初始（和最小大小）
>
> -XX:MaxMetaspaceSize=N //设置Metaspace的最大大小



**b**

运行时常量池是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池信息（用于存放编译期生成的各种字面量和符号引用）**JDK1.7及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。**

![image-20210125145959544](https://gitee.com/CTLQAQ/picgo/raw/master/image-20210125145959544.png)



### 

**直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 异常出现。**



### JAVA对象创建过程

1. 类加载检查

2. 分配内存。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。**分配方式**有 **“指针碰撞”** 和 **“空闲列表”** 两种，**选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定**。

   > - 指针碰撞。用过的内存全部整合到一边，没有用过的内存放到另一边，中间有一个分界值指针，只要向着没有用过的内存方向将该指针移动对象内存大小即可。GC收集器：Serial , ParNew
   > - 空闲列表。虚拟机会维护一个列表，该列表会记录哪些内存块是可用的，在分配的时候，找一块足够大的内存块来划分给对象实例。

3. 初始化零值。这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。

4. 设置对象头。**虚拟机要对对象进行必要的设置**，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 **这些信息存放在对象头中**。

5. 执行init方法，初始化。。

### 对象的访问定位有哪2种方式

我们的Java程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式有虚拟机实现而定，目前主流的访问方式有**①使用句柄**和**②直接指针**两种：

1. **句柄：** 如果使用句柄的话，那么**Java堆中将会划分出一块内存来作为句柄池**，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息；

   ![image-20210220111724144](https://gitee.com/CTLQAQ/picgo/raw/master/image-20210220111724144.png)
   
2. **直接指针：** 如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference 中存储的直接就是对象的地址。

   ![image-20210220112609537](https://gitee.com/CTLQAQ/picgo/raw/master/image-20210220112609537.png)

3. **这两种对象访问方式各有优势。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。**

### 简单聊一聊JVM垃圾回收

Java 堆是垃圾收集器管理的主要区域，因此也被称作**GC 堆（Garbage Collected Heap）**.从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代：再细致一点有：Eden 空间、From Survivor、To Survivor 空间等。**进一步划分的目的是更好地回收内存，或者更快地分配内存。**

大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加 1(Eden 区->Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 `-XX:MaxTenuringThreshold` 来设置。

> 修正（[issue552](https://github.com/Snailclimb/JavaGuide/issues/552)）：“Hotspot 遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了 survivor 区的一半时，取这个年龄和 MaxTenuringThreshold 中更小的一个值，作为新的晋升年龄阈值”。

### 堆内存中对象分配的基本策略

- 对象优先分配到eden区
- 大对象直接进入老年代
- 长期存活的对象将进入老年代

最简单的分代式GC策略，按照HotSpot VM的serialGC实现来看

- youngGC: 当eden区分配满的时候会触发。youngGC中有部分对象会晋升到oldgen。所以youngGC之后，老年代占用量通常会有所升高。
- full GC：当要准备触发一次YoungGC的时候，如果发现younggc晋升大小大于old gen剩余空间，则会转而触发full gc（整个堆上的gc）

**总结：**

针对 HotSpot VM 的实现，它里面的 GC 其实准确分类只有两大种：

部分收集 (Partial GC)：

- 新生代收集（Minor GC / Young GC）：只对新生代进行垃圾收集；
- 老年代收集（Major GC / Old GC）：只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集；
- 混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。

整堆收集 (Full GC)：收集整个 Java 堆和方法区。



### 如何判断对象是否死亡

1. 引用计数法。给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加1；当引用失效，计数器就减1；任何时候计数器为0的对象就是不可能再被使用的。

2. 可达性分析算法。通过一系列称为**"GC Roots"**的根对象作为起始节点集合，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”(Reference Chain)，如果某个对象到GC Roots间没有任何引用链相连，或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的。

   ![image-20210220121813828](https://gitee.com/CTLQAQ/picgo/raw/master/image-20210220121813828.png)

   可作为GC Roots的对象:（看下就行）

   1. 在虚拟机栈(栈帧中的本地变量表)中引用的对象。
   2. 在方法区中类静态属性引用的对象。
   3. 在方法区中常量引用的对象，如字符串常量池(String Table)里的引用指向的对象。
   4. 在本地方法栈中JNI (即通常所说的Native方法)引用的对象。
   5. Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象比如NullPointExcepiton、 OutOfMemoryError等，还有系统类加载器。
   6. 所有被同步锁(synchronized关键字) 持有的对象。
   7. 反映Java虚拟机内部情况的JMXBean，用于监管 JVM 和 JRE 的其他组件的 MBean、JVMTI，是Java虚拟机提供的一整套后门。通过这套后门可以对虚拟机方方面面进行监控，分析，在JVMTI中注册的回调、本地代码缓存等。
   8. 除了这些固定的GC Roots集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象"临时性”地加入，共同构成完整GC Roots集合。

   

   

### 介绍一下强引用，软引用，弱引用，虚引用

**在JDK 1.2版之后，Java对引用的概念进行了扩充，将引用分为**

- **强引用**是最传统的”引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似"Object obj=new Object()"这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。
- **软引用**是用来描述一些还有用，但非必须的对象。软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。SoftReference类来实现软引用。SoftReference ss = new SoftReference<>("hello world");String rs = ss.get();
- **弱引用**也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。WeakReference类来实现弱引用。
- **虚引用**也称为“幽灵引用”或者"幻影引用”，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。PhantomReference类来实现虚引用。



### 如何判断一个常量是废弃的常量

假如在常量池中存在字符串 "abc"，如果当前没有任何String对象引用该字符串常量的话，就说明常量 "abc" 就是废弃常量。

### 如何判断一个类是无用的类

类需要同时满足下面 3 个条件才能算是 **“无用的类”** ：

- 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。
- 加载该类的 `ClassLoader` 已经被回收。
- 该类对应的 `java.lang.Class` 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。



### 垃圾收集算法有那些？

**标记清除算法**

首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象，也可以反过来，标记存活的对象，统一回收所有未被标记的对象。

**主要缺点有两个:**

- **执行效率不稳定**,如果Java堆中包含大量对象，而且其中大部分是需要被回收的，这时必须进行大量标记和清除的动作，导致标记和清除两个过程的执行效率都随对象数量增长而降低;
- **内存空间的碎片化问题**，标记、清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存，而不得不提前触发另一次垃圾收集动作。

![image-20210220142325857](https://gitee.com/CTLQAQ/picgo/raw/master/image-20210220142325857.png)

**复制算法**

为了解决效率问题，“复制”收集算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。

![image-20210220142434852](https://gitee.com/CTLQAQ/picgo/raw/master/image-20210220142434852.png)

**标记整理(Mark-Compact)**

复制算法在对象存活率较高时就要进行较多的复制操作，效率将会降低。所以在老年代一般不能直接选用这种算法。针对老年代对象的存亡特征。

​		其中的标记过程仍然与”标记清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存。标记清除算法与标记整理算法的本质差异在于前者是一种非移动式的回收算法，而后者是移动式的。



### **HotSpot 为什么要分为新生代和老年代？**

当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将 java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。

**比如在新生代中，每次收集都会有大量对象死去，所以可以选择复制算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。**

### 常见的垃圾收集器有哪些？

![image-20210220143423846](https://gitee.com/CTLQAQ/picgo/raw/master/image-20210220143423846.png)

Serial（串行）收集器是最基本、历史最悠久的垃圾收集器了。它的 **“单线程”** 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ **"Stop The World"** ），直到它收集结束。**新生代采用复制算法，老年代采用标记-整理算法。**

![image-20210220144028974](https://gitee.com/CTLQAQ/picgo/raw/master/image-20210220144028974.png)

优点：**简单而高效（与其他收集器的单线程相比）**。Serial 收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率。Serial 收集器对于运行在 Client 模式下的虚拟机来说是个不错的选择。

**ParNew 收集器**

**ParNew 收集器其实就是 Serial 收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器完全一样。**

**新生代采用复制算法，老年代采用标记-整理算法。**

![image-20210220144203993](https://gitee.com/CTLQAQ/picgo/raw/master/image-20210220144203993.png)

**Parallel Scavenge 收集器**

Parallel Scavenge 收集器也是使用复制算法的多线程收集器，它看上去几乎和 ParNew 都一样。 **那么它有什么特别之处呢？**

**Parallel Scavenge 收集器关注点是吞吐量（高效率的利用 CPU）。CMS 等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是 CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值。** Parallel Scavenge 收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解，手工优化存在困难的时候，使用 Parallel Scavenge 收集器配合自适应调节策略，把内存管理优化交给虚拟机去完成也是一个不错的选择。

**新生代采用复制算法，老年代采用标记-整理算法。**



老年代收集器

Serial old收集器,**Serial 收集器的老年代版本**，它同样是一个单线程收集器。它主要有两大用途：一种用途是在 JDK1.5 以及以前的版本中与 Parallel Scavenge 收集器搭配使用，另一种用途是作为 CMS 收集器的后备方案。

**Parallel  Old** 收集器

**Parallel Scavenge 收集器的老年代版本**。使用多线程和“标记-整理”算法。在注重吞吐量以及 CPU 资源的场合，都可以优先考虑 Parallel Scavenge 收集器和 Parallel Old 收集器。



**CMS收集器  **    （**Concurrent Mark Sweep**）

CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。

CMS（Concurrent Mark Sweep）收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。

从名字中的**Mark Sweep**这两个词可以看出，CMS 收集器是一种 **“标记-清除”算法**实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：

- **初始标记：** 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；
- **并发标记：** 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。
- **重新标记：** 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短
- **并发清除：** 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。

![image-20210220145646419](https://gitee.com/CTLQAQ/picgo/raw/master/image-20210220145646419.png)

从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：**并发收集、低停顿**。但是它有下面三个明显的缺点：

- **对 CPU 资源敏感；**
- **无法处理浮动垃圾；**
- **它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。**



**Garbage First (简称G1)收集器**

开创了收集器面向局部收集的设计思路和基于Region的内存布局形式。G1是一款主要面向服务端应用的垃圾收集器。

G1收集器出现之前的所有其他收集器，包括CMS在内，垃圾收集的目标范围要么是整个新生代(MinorGC)， 要么就是整个老年代(MajorGC)， 再要么就是整个Java堆(Full GC)。而G1跳出了这个樊笼，它可以面向堆内存任何部分来组成回收集(Collection Set,一般简称CSet)进行回收，衡量标准不再是它属于哪个分代，而是哪块内存中存放的垃圾数量最多，回收收益最大，这就是G1收集器的Mixed GC模式。

G1的各代存储地址是不连续的，每一代都使用了n个不连续的大小相同的Region，每个Region占有一块连续的虚拟内存地址。

![image-20210220150355997](https://gitee.com/CTLQAQ/picgo/raw/master/image-20210220150355997.png)

每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间， 或者老年代空间。收集器能够对扮演不同角色的Region采用不同的策略去处理，这样无论是新创建的对象还是已经存活了一段时间、熬过多次收集的旧对象都能获取很好的收集效果。**Region中还有一类特殊的Humongous区域，专门用来存储大对象**。G1认为只要大小超过了一个Region容量一半的对象即可判定为大对象。每个Region的大小可以通过参数
**-XX: G1HeapRegionSize**设定，取值范围为1MB ~ 32MB，且应为2的N次幂。而对于那些超过了整个Region容量的超级大对象，将会被存放在N个连续的Humongous Region之中，G1的大多数行为都把Humongous Region作为老年代的一部分来进行看待。

G1收集器去跟踪各个Region里面的垃圾堆积的**“价值”**大小，**价值**即回收所获得的空间大小以及回收所需时间的经验值，然后在后台维护一个优先级列表，每次根据用户设定允许的收集停顿时间(**使用参数**
**-XX: MaxGCPauseMilis指定， 默认值是200毫秒**)，优先处理回收价值最大的那些Region,这也就是"Garbage First"名字的由来。这种使用Region划分内存空间，以及具有优先级的区域回收方式，**保证了G1收集器在有限的时间内获取尽可能高的收集效率。**



G1 收集器的运作大致分为以下几个步骤：

- **初始标记**
- **并发标记**
- **最终标记**
- **筛选回收**







## NIO/BIO/AIO

### BIO、NIO、AIO 概念和区别

**BIO**

BIO又被称为阻塞式I/O模型。多线程的BIO中 ，客户端有连接请求时服务器端就需要启动一个线程进行处理。但是随着客户端的增多，服务端的线程数膨胀，系统性能急剧下降，最终会导致系统不可用。这种模型无法满足高并发，高性能的场景。

```java
public class SocketServer {
    public static void main(String[] args) throws IOException {
        ServerSocket serverSocket = new ServerSocket(9000);
        while (true) {
            System.out.println("等待连接。。");
            //阻塞方法
            Socket clientSocket = serverSocket.accept();
            System.out.println("有客户端连接了。。");
            handler(clientSocket);

            /*new Thread(new Runnable() {
                @Override
                public void run() {
                    try {
                        handler(clientSocket);
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                }
            }).start();*/
        }
    }

    private static void handler(Socket clientSocket) throws IOException {
        byte[] bytes = new byte[1024];
        System.out.println("准备read。。");
        //接收客户端的数据，阻塞方法，没有数据可读时就阻塞
        int read = clientSocket.getInputStream().read(bytes);
        System.out.println("read完毕。。");
        if (read != -1) {
            System.out.println("接收到客户端的数据：" + new String(bytes, 0, read));
        }
        clientSocket.getOutputStream().write("HelloClient".getBytes());
        clientSocket.getOutputStream().flush();
    }
}
```



**NIO (Non-blocking/New I/O)**

同步非阻塞，服务器实现模式为**一个线程可以处理多个请求(连接)**，客户端发送的连接请求都会注册到**多路复用器selector**上,  多路复用器轮询到连接有IO请求就进行处理。

**应用场景：**

NIO方式适用于连接数目多且连接比较短（轻操作） 的架构， 比如聊天服务器， 弹幕系统， 服务器间通讯，编程比较复杂

**NIO引入多路复用器代码示例：**

```java
public class NioSelectorServer {

    public static void main(String[] args) throws IOException, InterruptedException {

        // 创建NIO ServerSocketChannel
        ServerSocketChannel serverSocket = ServerSocketChannel.open();
        serverSocket.socket().bind(new InetSocketAddress(9000));
        // 设置ServerSocketChannel为非阻塞
        serverSocket.configureBlocking(false);
        // 打开Selector处理Channel，即创建epoll
        Selector selector = Selector.open();
        // 把ServerSocketChannel注册到selector上，并且selector对客户端accept连接操作感兴趣
        serverSocket.register(selector, SelectionKey.OP_ACCEPT);
        System.out.println("服务启动成功");

        while (true) {
            // 阻塞等待需要处理的事件发生
            selector.select();

            // 获取selector中注册的全部事件的 SelectionKey 实例
            Set<SelectionKey> selectionKeys = selector.selectedKeys();
            Iterator<SelectionKey> iterator = selectionKeys.iterator();

            // 遍历SelectionKey对事件进行处理
            while (iterator.hasNext()) {
                SelectionKey key = iterator.next();
                // 如果是OP_ACCEPT事件，则进行连接获取和事件注册
                if (key.isAcceptable()) {
                    ServerSocketChannel server = (ServerSocketChannel) key.channel();
                    SocketChannel socketChannel = server.accept();
                    socketChannel.configureBlocking(false);
                    // 这里只注册了读事件，如果需要给客户端发送数据可以注册写事件
                    socketChannel.register(selector, SelectionKey.OP_READ);
                    System.out.println("客户端连接成功");
                } else if (key.isReadable()) {  // 如果是OP_READ事件，则进行读取和打印
                    SocketChannel socketChannel = (SocketChannel) key.channel();
                    ByteBuffer byteBuffer = ByteBuffer.allocate(128);
                    int len = socketChannel.read(byteBuffer);
                    // 如果有数据，把数据打印出来
                    if (len > 0) {
                        System.out.println("接收到消息：" + new String(byteBuffer.array()));
                    } else if (len == -1) { // 如果客户端断开连接，关闭Socket
                        System.out.println("客户端断开连接");
                        socketChannel.close();
                    }
                }
                //从事件集合里删除本次处理的key，防止下次select重复处理
                iterator.remove();
            }
        }
    }
}
```

上面函数的调用过程：

**首先，会调用系统调用epoll_create创建epoll实例，然后把，ServerSocketChannel 加入到一个集合，再然后调用epoll_ctl() 为其绑定事件ACCEPT，然后调用selector.select() ，这个方法会调用epoll_wait(), 当Socket收到数据的时候，OS会通过中断机制，把对应的socket引用加入到epoll实例的就绪列表中。此时可以根据事件，做出不同的操作，如果是ACCEPT事件，则需要获得对应的ServerSocketChannel ，并调用其Socket方法，获得SocketChannel, 把新的到的SocketChannel 注册到多路复用器上，绑定事件READ（即服务器接收来自客户端的数据）。**

**此时如果客户端发送数据，那么服务器Socket收到数据后，OS启动中断机制，把对应的socket（就是SocketChannel）加入epoll实例的就绪列表中，然后遍历对其进行处理。**

| java                                                     | linux内核方法                            |
| -------------------------------------------------------- | ---------------------------------------- |
| Selector.open();                                         | 调用epoll_create                         |
| selector.select();                                       | epoll_wait()，阻塞等待需要处理的事件发生 |
| serverSocket.register(selector, SelectionKey.OP_ACCEPT); | 调用epoll_ctl() 为其绑定事件ACCEPT       |

NIO 有三大核心组件： **Channel(通道)， Buffer(缓冲区)，Selector(多路复用器)**

1、channel 类似于流，每个 channel 对应一个 buffer缓冲区，buffer 底层就是个数组

2、channel 会注册到 selector 上，由 selector 根据 channel 读写事件的发生将其交由某个空闲的线程处理

3、NIO 的 Buffer 和 channel 都是既可以读也可以写

**AIO**

AIO 也就是 NIO 2。Java 7 中引入了 NIO 的改进版 NIO 2,它是异步 IO 模型。

异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。

目前来说 AIO 的应用还不是很广泛。Netty 之前也尝试使用过 AIO，不过又放弃了。这是因为，Netty 使用了 AIO 之后，在 Linux 系统上的性能并没有多少提升。

AIO代码示例：

```java
public class AIOServer {

    public static void main(String[] args) throws Exception {
        final AsynchronousServerSocketChannel serverChannel =
                AsynchronousServerSocketChannel.open().bind(new InetSocketAddress(9000));

        serverChannel.accept(null, new CompletionHandler<AsynchronousSocketChannel, Object>() {
            @Override
            public void completed(AsynchronousSocketChannel socketChannel, Object attachment) {
                try {
                    System.out.println("2--"+Thread.currentThread().getName());
                    // 再此接收客户端连接，如果不写这行代码后面的客户端连接连不上服务端
                    serverChannel.accept(attachment, this);
                    System.out.println(socketChannel.getRemoteAddress());
                    ByteBuffer buffer = ByteBuffer.allocate(1024);
                    socketChannel.read(buffer, buffer, new CompletionHandler<Integer, ByteBuffer>() {
                        @Override
                        public void completed(Integer result, ByteBuffer buffer) {
                            System.out.println("3--"+Thread.currentThread().getName());
                            buffer.flip();
                            System.out.println(new String(buffer.array(), 0, result));
                            socketChannel.write(ByteBuffer.wrap("HelloClient".getBytes()));
                        }

                        @Override
                        public void failed(Throwable exc, ByteBuffer buffer) {
                            exc.printStackTrace();
                        }
                    });
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }

            @Override
            public void failed(Throwable exc, Object attachment) {
                exc.printStackTrace();
            }
        });

        System.out.println("1--"+Thread.currentThread().getName());
        Thread.sleep(Integer.MAX_VALUE);
    }
}
```



## 多线程



### 线程按序交替ABC

线程交替输出j

方法1，使用信号量机制

```java
public class Main {
	public static void main(String[] args) {
		//奇数线程需要获得的资源
		Semaphore a = new Semaphore(1);
		//偶数线程需要获得的资源
		Semaphore b = new Semaphore(0);
		new Thread(() -> {
			try {
				for (int i = 1;  i < 100; i += 2) {
					a.acquire();
					System.out.println("线程1：" + i);
					b.release();
				}
			} catch (InterruptedException e) {
				e.printStackTrace();
			}

		}).start();
		new Thread(() -> {
			try {
				for (int i = 2; i < 100; i += 2) {
					b.acquire();
					System.out.println("线程2：" + i);
					a.release();
				}
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}).start();
	}
}
```

方法2：使用synchronized

```java
public class Main {
	static Object obj = new Object();
	static volatile int i = 0;
	public static void main(String[] args) {
		new Thread(()->{
			//判断数值是否小于100，小于则进入同步块做判断输出和自增
			while (i <= 100) {
				synchronized (obj) {
					//等价于number%2==0，用位运算效率更高
					if ((i & 1) == 0) {
						System.out.println(Thread.currentThread().getName() + ":" + i++);
					}
				}
			}

		}, "偶数").start();

		new Thread(()->{
			//判断数值是否小于100，小于则进入同步块做判断输出和自增
			while (i < 100) {
				synchronized (obj) {
					//等价于number%2==0，用位运算效率更高
					if ((i & 1) != 0) {
						System.out.println(Thread.currentThread().getName() + ":" + i++);
					}
				}
			}

		}, "奇数").start();
	}
}

```

方法3

```java
//定义一个int变量
    private static volatile int number = 0;

    //定义一个对象锁
    private static final Object lock = new Object();

    static class NumberThread implements Runnable {
        @Override
        public void run() {
            //小于等于100则进入同步块
            while (number <= 100) {
                synchronized (lock) {
                    //输出当前值后加一
                    System.out.println(Thread.currentThread().getName() + ":" + number++);
                    //唤醒等待中的线程
                    lock.notify();
                    //这个判断很关键，要是不写，结果输出虽然是一样的，但是程序运行不会结束，因为有线程会陷入无限的等待，而没有其他线程可以来唤醒它
                    if (number <= 100) {
                        try {
                            //让出CPU资源，释放锁，让另一个线程运行，同时等待被另一个线程唤醒
                            lock.wait();
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                }
            }
        }
    }

    public static void main(String[] args) throws InterruptedException {
        long startTime = System.currentTimeMillis();
        NumberThread numberThread = new NumberThread();
        Thread thread1 = new Thread(numberThread, "偶数");
        Thread thread2 = new Thread(numberThread, "奇数");
        thread1.start();
        thread2.start();
        thread1.join();
        thread2.join();
        System.out.println("总耗时：" + (System.currentTimeMillis() - startTime) + "毫秒");
    }
```





http://rawcdn.githack.com/TylerChenPDS/supermall/master/vue.config.js

### 为什么要使用多线程？

线程可以比作是轻量级的进程，是程序执行的最小单位,线程间的切换和调度的成本远远小于进程。另外，多核 CPU 时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。

有了多线程之后，进程是资源调度的基本单位，而线程是处理机调度的基本单位。

### Sleep方法和wait方法的区别

- 两者最主要的区别在于：**`sleep()` 方法没有释放锁，而 `wait()` 方法释放了锁** 。
- 两者都可以暂停线程的执行。
- `wait()` 通常被用于线程间交互/通信，`sleep()`通常被用于暂停执行。
- `wait()` 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 `notify()`或者 `notifyAll()` 方法。`sleep()`方法执行完成后，线程会自动苏醒。或者可以使用 `wait(long timeout)` 超时后线程会自动苏醒。

### synchronized 关键字最主要的三种使用方式：

**1.修饰实例方法:** 作用于当前对象实例加锁，进入同步代码前要获得 **当前对象实例的锁**

**2.修饰静态方法:** 也就是给当前类加锁，会作用于类的所有对象实例 ，进入同步代码前要获得 **当前 class 的锁**。

**3.修饰代码块** ：指定加锁对象，对给定对象/类加锁。

```java
public class Singleton {

    private volatile static Singleton uniqueInstance;

    private Singleton() {
    }

    public static Singleton getUniqueInstance() {
       //先判断对象是否已经实例过，没有实例化过才进入加锁代码
        if (uniqueInstance == null) {
            //类对象加锁
            synchronized (Singleton.class) {
                if (uniqueInstance == null) {
                    uniqueInstance = new Singleton();
                }
            }
        }
        return uniqueInstance;
    }
}
```

### 简要介绍一下ThreadLocal 

通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。**如果想实现每一个线程都有自己的专属本地变量该如何解决呢？** JDK 中提供的`ThreadLocal`类正是为了解决这样的问题。 **`ThreadLocal`类主要解决的就是让每个线程绑定自己的值，可以将`ThreadLocal`类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。**

**如果你创建了一个`ThreadLocal`变量，那么访问这个变量的每个线程都会有这个变量的本地副本，这也是`ThreadLocal`变量名的由来。他们可以使用 `get（）` 和 `set（）` 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。**



### 原理

Thread源码里面有2个变量

```
public class Thread implements Runnable {
 ......
//与此线程有关的ThreadLocal值。由ThreadLocal类维护
ThreadLocal.ThreadLocalMap threadLocals = null;

//与此线程有关的InheritableThreadLocal值。由InheritableThreadLocal类维护
ThreadLocal.ThreadLocalMap inheritableThreadLocals = null;
 ......
}
```

ThreadLocalMap, key是ThreadLocal变量，value是ThreadLocal设置的值。

**下面是TreadLoacal的源代码**

**set方法**

```java
public void set(T value) {
    //(1)获取当前线程（调用者线程）
    Thread t = Thread.currentThread();
    //(2)以当前线程作为key值，去查找对应的线程变量，找到对应的map
    ThreadLocalMap map = getMap(t);
    //(3)如果map不为null，就直接添加本地变量，key为当前线程，值为添加的本地变量值
    if (map != null)
        map.set(this, value);
    //(4)如果map为null，说明首次添加，需要首先创建出对应的map
    else
        createMap(t, value);
}
```

getMap

```java
ThreadLocalMap getMap(Thread t) {
    return t.threadLocals; //获取线程自己的变量threadLocals，并绑定到当前调用线程的成员变量threadLocals上
}
```

createMap

```java
 void createMap(Thread t, T firstValue) {
     t.threadLocals = new ThreadLocalMap(this, firstValue);
 }
```

**get**

```java
public T get() {
    //(1)获取当前线程
    Thread t = Thread.currentThread();
    //(2)获取当前线程的threadLocals变量
    ThreadLocalMap map = getMap(t);
    //(3)如果threadLocals变量不为null，就可以在map中查找到本地变量的值
    if (map != null) {
        ThreadLocalMap.Entry e = map.getEntry(this);
        if (e != null) {
            @SuppressWarnings("unchecked")
            T result = (T)e.value;
            return result;
        }
    }
    //(4)执行到此处，threadLocals为null，调用该更改初始化当前线程的threadLocals变量
    return setInitialValue();
}

private T setInitialValue() {
    //protected T initialValue() {return null;}
    T value = initialValue();
    //获取当前线程
    Thread t = Thread.currentThread();
    //以当前线程作为key值，去查找对应的线程变量，找到对应的map
    ThreadLocalMap map = getMap(t);
    //如果map不为null，就直接添加本地变量，key为当前线程，值为添加的本地变量值
    if (map != null)
        map.set(this, value);
    //如果map为null，说明首次添加，需要首先创建出对应的map
    else
        createMap(t, value);
    return value;
}
```

通过上面这些内容，我们足以通过猜测得出结论：**最终的变量是放在了当前线程的 `ThreadLocalMap` 中，并不是存在 `ThreadLocal` 上，`ThreadLocal` 可以理解为只是`ThreadLocalMap`的封装，传递了变量值。** `ThrealLocal` 类中可以通过`Thread.currentThread()`获取到当前线程对象后，直接通过`getMap(Thread t)`可以访问到该线程的`ThreadLocalMap`对象。

**`ThreadLocal` 内部维护的是一个类似 `Map` 的`ThreadLocalMap` 数据结构，`key` 为当前对象的 `Thread` 对象，值为 Object 对象。**



### ThreadLocal 内存泄漏问题

通过上面这些内容，我们足以通过猜测得出结论：**最终的变量是放在了当前线程的 `ThreadLocalMap` 中，并不是存在 `ThreadLocal` 上，`ThreadLocal` 可以理解为只是`ThreadLocalMap`的封装，传递了变量值。** `ThrealLocal` 类中可以通过`Thread.currentThread()`获取到当前线程对象后，直接通过`getMap(Thread t)`可以访问到该线程的`ThreadLocalMap`对象。

**`ThreadLocal` 内部维护的是一个类似 `Map` 的`ThreadLocalMap` 数据结构，`key` 为当前对象的 `Thread` 对象，值为 Object 对象。**

```java
static class Entry extends WeakReference<ThreadLocal<?>> {
    /** The value associated with this ThreadLocal. */
    Object value;

    Entry(ThreadLocal<?> k, Object v) {
        super(k);
        value = v;
    }
}
```

> 弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。





https://blog.csdn.net/TZ845195485/article/details/109210263

### 什么情况下使用线程池？

1.单个任务处理的时间比较短
2.将需处理的任务的数量大

### 实现线程池的好处？

- 1.降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。
- 2.提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。
- 3.提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。

### 使用 Executors 的工厂方法创建线程

- newCachedThreadPool：

  创建一个可缓存线程池

  优点：很灵活，弹性的线程池线程管理，用多少线程给多大的线程池，不用后及时回收，用则新建

  缺点：一旦线程无限增长，会导致内存溢出。

- newFixedThreadPool ：

  优点：创建一个固定大小线程池，超出的线程会在队列中等待。

  缺点：不支持自定义拒绝策略，大小固定，难以扩展

- newScheduledThreadPool ：

  优点：创建一个固定大小线程池，可以定时或周期性的执行任务。

  缺点：任务是单线程方式执行，一旦一个任务失败其他任务也受影响

- newSingleThreadExecutor ：

  优点：创建一个单线程的线程池，保证线程的顺序执行

  缺点：不适合并发。。

- **统一缺点：**不支持自定义拒绝策略

Executors 返回的线程池对象的弊端如下： 

1） FixedThreadPool 和 SingleThreadPool: 

允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。 

2） CachedThreadPool 和 ScheduledThreadPool: 

允许的创建线程数量为 Integer.MAX_VALUE， 可能会创建大量的线程，从而导致 OOM。



### BlockingQueue 

一个阻塞队列，**用来存储等待执行的任务**，常用的有如下几种：
**ArrayBlockingQueue**：是一个基于数组结构的有界阻塞队列，此队列按 FIFO（先进先出）原则对元素进行排序。
**LinkedBlockingQueue**：一个基于链表结构的阻塞队列，此队列按FIFO （先进先出） 排序元素，吞吐量通常要高于	
**ArrayBlockingQueue**。静态工厂方法Executors.newFixedThreadPool()使用了这个队列。
**SynchronousQueue**：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQueue，静态工厂方法Executors.newCachedThreadPool使用了这个队列。
**PriorityBlockingQueue**：一个具有优先级得无限阻塞队列。



如果阻塞队列满了，需要用到拒绝策略

RejectedExecutionHandler : 当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。有下面四种JDK提供的策略：
**AbortPolicy**，表示无法处理新任务时抛出异常, 默认策略
**CallerRunsPolicy**：用调用者所在线程来运行任务。
**DiscardOldestPolicy**： 该策略将丢弃最老的一个请求，也就是丢弃即将被执行的任务，并尝试再次提交当前任务。
**DiscardPolicy**：不处理，丢弃掉 
除了这些JDK提供的策略外，还可以自己实现 RejectedExecutionHandler 接口定义策略。



### Java 怎么保证多线程的安全

1. 使用volatile( 不稳定的、反复无常的)，或者 synchronized关键字解决内存可见性问题。
2. 可以使用锁机制，synchronized，和CAS来解决原子性问题
3. 可以使用信号量机制解决同步问题。

### JAVA内存模型

- 所有的变量都存储在主内存中（**操作系统给进程分配的内存空间**）
- **每个线程都有自己独立的工作内存，里面保存该线程使用到的变量的副本**

![image-20210126160641338](https://gitee.com/CTLQAQ/picgo/raw/master/image-20210126160641338.png)

- 线程对共享变量的所有操作都必须在自己的工作内存（working memory,是cache和寄存器的一个抽象，而并不是内存中的某个部分）**不同线程之间，当前线程无法直接访问其他线程的工作内存中的变量，线程间变量值得传递需要通过主内存来完成**

**共享变量可见性的实现原理**

- **把工作内存1中更新过的共享变量刷新到主内存中**
- **将主内存中最新的共享变量的值更新到工作内存2中**

### 内存可见性

**内存可见性其实就是共享变量在线程间的可见性**

- **共享变量**：如果一个变量在多个线程的工作内存中都存在**副本**，那么这个变量就是这几个线程的共享变量
- **可见性**：一个线程对共享变量值的修改，能够及时的被其他线程看到

```java
public class TestVolatile {
    public static void main(String[] args) {
        ThreadDemo td = new ThreadDemo();
        new Thread(td).start();
        while(true){
            if(td.isFlag()){
                System.out.println("--------主线中的程序读到flag为true了----------");
                break;
            }
//这里不能有语句，有语句循环之间就有间隙
        }
    }
}

class ThreadDemo implements Runnable {
    private boolean flag = false;
    //private volatile boolean flag = false; 加上volatile之后，程序可以正常终止
    @Override
    public void run() {
        try {
            Thread.sleep(200);
        } catch (InterruptedException e) {
        }
        flag = true;
        System.out.println("flag=" + isFlag());
    }
    public boolean isFlag() {
        return flag;
    }
    public void setFlag(boolean flag) {
        this.flag = flag;
    }
}
```

主内存中存在flag = false，线程td启动后，将flag = false，放到自己的工作内存中，然后睡眠1秒，这期间，（因为要使用）主线程也把flag = false放到自己的工作内存放到自己的工作空间。td线程把flag = true由刷新到主内存中，但是主线程工作空间内的flag还是false。也就是说，td对共享变量的修改对主线程“不可见了”。所以上面的线程不会停止。

### 解决内存可见性的方法

使用volatile之后，td将更改刷到主存中后，会告知main线程

使用**synchronized**

JMM关于synchronized的两条规定：

- **线程解锁前，必须把共享变量的最新值刷新到主内存中**
- **线程加锁时，将清空工作内存中共享变量的值，从而使用共享变量时需要从主内存中重新读取最新的值** 



### **synchronized和volatile比较**

- volatile不需要加锁，比synchronized更轻量级，不会阻塞线程，效率更高

- volatile不具备“互斥性”，synchronized就具备“互斥性”

  - 何为互斥性？

    比方说当我们用synchronize修饰方法，

    当一个线程抢到锁执行该方法后另一个线程无法再抢到锁执行该方法

- synchronized既能保证可见性，又能保证原子性，而volatile只能保证可见性，不能保证原子性。

- 如果能用volatile解决问题，还是应尽量使用volatile，因为它的效率更高 



### 原子性

经典不具有原子性的操作,包括读取变量的原始值、进行加1操作、写入工作内存

```java
public int getSerialNumber(){
    return serialNumber++; //这个操作不具有原子性；
}
```

里边封装了一系列常用的数据类型对应的封装类，

Java.util.concurrent.atomic中实现的原子操作类包括：

AtomicBoolean、AtomicInteger、AtomicLong、AtomicReference。

**这些类都保证了两点：**

- **类里的变量都用了volatile保证内存是可见的**
- 使用了一个算法**CAS**，保证对这些数据的操作具有原子性

### CAS （Compare and Swap）

- **悲观锁：传统的锁机制**，例如 java 的 synchronized 关键字，他代表了 java 中悲观锁技术，保证了某一时刻仅有一个线程能访问同步代码/方法。synchronized 能够很好地工作，却有着 (相对) 比较大的性能开销。
- **乐观锁** (相对悲观锁) 对性能会有很大的帮助。他的核心思想是：寄希望于在没有冲突的情况下完成一次更新操作，使用乐观锁技术更新时会进行 “冲突检测” 来判断是否有其他的线程干扰，若是 (有其他线程干扰) 则视本次更新操作失败，一般会进行重试。在数据库中就是多版本控制，最后 更新的时候 会`update ... set version = ${version} + 1 ... where version = ${version}`, 如果version被别人修改了，则我这次修改失败。乐观锁不会使用数据库提供的锁机制，一般在表中添加version字段来实现。
- Compare and Swap 就是典型的乐观锁技术

**CAS是通过硬件命令保证了原子性 ** CAS有3个操作数，**内存值V，旧的预期值A，要修改的新值B**。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则返回V。

就是指当V和A两者进行比较时，如果相等，则证明共享数据没有被修改，替换成新值，然后继续往下运行；如果不相等，说明共享数据已经被修改，放弃已经所做的操作，然后重新执行刚才的操作。这样子，就能保证操作的原子性了。

栗子：

![image-20210126162533637](https://gitee.com/CTLQAQ/picgo/raw/master/image-20210126162533637.png)

例如：t1，t2线程是同时更新同一变量56的值。因为t1和t2线程都同时去访问同一变量值56，所以他们会把主内存的值完全拷贝一份到自己的工作内存空间，所以t1和t2线程的预期值都为56。假设此时t1 竞争到了CPU，t1的旧的预期值为56 与内存值56相等，于是它可以把共享变量修改成57。 此时t2 又竞争到了CPU，t2的预期值与主内存中的不一样，所以他就要放弃此次修改，然后重试。

### JUC强大的三个工具类

CountDownLatch | CyclicBarrier | Semaphore 底层都是AQS来实现的

**CountDownLatch(闭锁)**

- CountDownLatch主要有两个方法，当一个或多个线程调用await方法时，这些线程会阻塞
- 其它线程调用countDown方法会将计数器减1(调用countDown方法的线程不会阻塞)
- 计数器的值变为0时，因await方法阻塞的线程会被唤醒，继续执行

栗子:  要求6个线程都执行完了,mian线程最后执行

```java

public class CountDownLatchDemo {
    public static void main(String[] args) throws Exception{

        CountDownLatch countDownLatch=new CountDownLatch(6);
        for (int i = 1; i <=6; i++) {
            new Thread(()->{
                System.out.println(Thread.currentThread().getName()+"\t");
                countDownLatch.countDown();
            },i+"").start();
        }
        countDownLatch.await();
        System.out.println(Thread.currentThread().getName()+"\t班长关门走人，main线程是班长");
    }
}
```

**CyclicBarrier**

CyclicBarrier的字面意思是可循环(Cyclic) 使用的屏障(barrier).它要做的事情是,让一组线程到达一个屏障(也可以叫做同步点)时被阻塞,直到最后一个线程到达屏障时,屏障才会开门,所有被屏障拦截的线程才会继续干活,线程进入屏障通过CyclicBarrier的await()方法

```java
    //集齐7颗龙珠就能召唤神龙
	public class CyclicBarrierDemo {
	    public static void main(String[] args) {
	        // public CyclicBarrier(int parties, Runnable barrierAction) {}
	        CyclicBarrier cyclicBarrier=new CyclicBarrier(7,()->{
	            System.out.println("召唤龙珠");
	        });
	        for (int i = 1; i <=7; i++) {
	            final int temp=i;
	            new Thread(()->{
	                System.out.println(Thread.currentThread().getName()+"\t收集到了第"+temp+"颗龙珠");
	                try {
	                    cyclicBarrier.await();
	                } catch (InterruptedException e) {
	                    e.printStackTrace();
	                } catch (BrokenBarrierException e) {
	                    e.printStackTrace();
	                }
	            }).start();
	        }
	
	    }
	}

```

**Semaphore(信号量)**

- ①. acquire（获取） 当一个线程调用acquire操作时，它要么通过成功获取信号量（信号量减1），要么一直等下去，直到有线程释放信号量，或超时。
- ②. release（释放）实际上会将信号量的值加1，然后唤醒等待的线程。
- ③. 信号量主要用于两个目的，一个是用于多个共享资源的互斥使用，另一个用于并发线程数的控制。









### Synchronized 的底层实现

https://www.jianshu.com/p/c97227e592e1

![image-20210127175442004](https://gitee.com/CTLQAQ/picgo/raw/master/image-20210127175442004.png)

![image-20210127175528382](https://gitee.com/CTLQAQ/picgo/raw/master/image-20210127175528382.png)

`synchronized`修饰的方法在字节码中添加了一个`ACC_SYNCHRONIZED`的flags,同步代码块则是在同步代码块前插入`monitorenter`，在同步代码块结束后插入`monitorexit`。

这两者的处理是分别是这样的：当线程执行到某个方法时，JVM会去检查该方法的`ACC_SYNCHRONIZED`访问标志是否被设置，如果设置了那线程会去获取这个对象所对应的`monitor`对象（每一个对象都有且仅有一个与之对应的`monitor`对象）,获取成功后才执行方法体，方法执行完再释放`monitor`对象，在这一期间，任何其他线程都无法获得这个`monitor`对象

而线程执行同步代码块时遇到的`monitorenter`和`monitorexit`指令依赖`monitor`对象完成。这两者实现的方式本质上无区别，只是方法的同步是一种隐式的方式，不通过字节码实现。



1. 每个锁对象拥有一个锁计数器和一个指向持有该锁的线程的指针
2. 当执行monitorenter时,如果目标锁对象的计数器为零,那么说明它没有被其他线程持有,Java虚拟机会将该锁对象的持有线程设置为当前线程,并且将其计数器加1,否则需要等待,直至持有线程释放该锁
3. 当执行monitorexit时,Java虚拟机则锁对象的计数器减1。计数器为零代表锁已经被释放

### AQS 是什么

AQS 是一个用来构建锁和同步器的框架，使用 AQS 能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的 `ReentrantLock`，`Semaphore`，其他的诸如 `ReentrantReadWriteLock`，`SynchronousQueue`，`FutureTask` 等等皆是基于 AQS 的。当然，我们自己也能利用 AQS 非常轻松容易地构造出符合我们自己需求的同步器。

### AQS 原理

**AQS 核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用 CLH 队列锁实现的，即将暂时获取不到锁的线程加入到队列中。**

AQS 使用一个 int 成员变量来表示同步状态，通过内置的 FIFO 队列来完成获取资源线程的排队工作。AQS 使用 CAS 对该同步状态进行原子操作实现对其值的修改。

**AQS 定义两种资源共享方式**

- Exclusive

  （独占）：只有一个线程能执行，如ReentrantLock

  又可分为公平锁和非公平锁：

  - 公平锁：按照线程在队列中的排队顺序，先到者先拿到锁
  - 非公平锁：当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的

- **Share**（共享）：多个线程可同时执行，如`CountDownLatch`、`Semaphore`、`CountDownLatch`、 `CyclicBarrier`、`ReadWriteLock` 我们都会在后面讲到。

**AQS底层是使用了模板方法**

同步器的设计是基于模板方法模式的，如果需要自定义同步器一般的方式是这样（模板方法模式很经典的一个应用）：

1. 使用者继承 `AbstractQueuedSynchronizer` 并重写指定的方法。（这些重写方法很简单，无非是对于共享资源 state 的获取和释放）
2. 将 AQS 组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。

这和我们以往通过实现接口的方式有很大区别，这是模板方法模式很经典的一个运用。

**AQS 使用了模板方法模式，自定义同步器时需要重写下面几个 AQS 提供的模板方法：**

```java
isHeldExclusively()//该线程是否正在独占资源。只有用到condition才需要去实现它。
tryAcquire(int)//独占方式。尝试获取资源，成功则返回true，失败则返回false。
tryRelease(int)//独占方式。尝试释放资源，成功则返回true，失败则返回false。
tryAcquireShared(int)//共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。
tryReleaseShared(int)//共享方式。尝试释放资源，成功则返回true，失败则返回false。
```

以 ReentrantLock 为例，state 初始化为 0，表示未锁定状态。A 线程 lock()时，会调用 tryAcquire()独占该锁并将 state+1。此后，其他线程再 tryAcquire()时就会失败，直到 A 线程 unlock()到 state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A 线程自己是可以重复获取此锁的（state 会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证 state 是能回到零态的。



再以 `CountDownLatch` 以例，任务分为 N 个子线程去执行，state 也初始化为 N（注意 N 要与线程个数一致）。这 N 个子线程是并行执行的，每个子线程执行完后`countDown()` 一次，state 会 CAS(Compare and Swap)减 1。等到所有子线程都执行完后(即 state=0)，会 unpark()主调用线程，然后主调用线程就会从 `await()` 函数返回，继续后余动作。



一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现`tryAcquire-tryRelease`、`tryAcquireShared-tryReleaseShared`中的一种即可。但 AQS 也支持自定义同步器同时实现独占和共享两种方式，如`ReentrantReadWriteLock`。









# 设计模式



# 自我介绍



# 项目介绍

## 危险废物管理系统

### 权限模块

权限模块涉及的表：user， user_role, role, role_reource, resource

resource的基本结构

![image-20210218213224863](https://gitee.com/CTLQAQ/picgo/raw/master/image-20210218213224863.png)

当用户首次登陆成功的时候，我们会为用户生成一个token里面包含了用户的可见的基本信息，我们将其拥有的权限信息从数据库中查询出来，并将其保存到redis缓存中去。并将该用户拥有的权限字符串全部返回到前台，我们前台的菜单是写死的，我们对每一个侧边栏，以及按钮都分配一个权限字符串，如果该字符串包含于刚才返回用户拥有的字符串，则渲染对应的侧边栏，或者按钮。

我们在网关模块设置拦截器，当用户点击按钮发起url请求的时候，我们对url进行检查，判断它有没有访问该url的权限。其实就是读取redis中对应token拥有的url信息。

### 唯一订单号的生成

客户要求，订单号为  订单标识符+日期时间+当日第几单。当日第几单需要自己去设计。

为此，创建了一个新的关系表，里面有2个字段，一个是bussiness_name 业务名称, id 对应的最大id。

然后创建一个存储过程，每当需要获取订单号的时候，就调用存储过程获取订单号。规则为：**根据业务名称获取对应的id,并为其加上行锁**，也就是排他锁。当前事务没有结束时，阻断其他的读锁和写锁。这样当第二个线程想要获取订单号时，就要等待上一个加锁的线程，保证了订单号的唯一性。获取到最大id后，将id+1，并且修改doc_id对应业务的最大id为id+1，最后将新的id返回。

考虑到凌晨12：00不会接单，所以设置定时任务，没天12：00定时把上面创建业务表id设置成0；

## 羽毛球场馆预定系统

### 通知功能

主要有三张表：t_notce, t_notice_rel_user, user。

![image-20210219165337310](https://gitee.com/CTLQAQ/picgo/raw/master/image-20210219165337310.png)

通知主要分2类，针对所有用户的通知（如，场地维护，开/闭馆日期等等），和针对某个特定用户的通知（比如，离预约时间差15分钟就发一个通知提醒）。在notice表中有一个字段target_is_all, 如果这个字段为1，则说明这是针对所有用户的。每次用户登录的时候，都要向服务器发起请求，查询针对所有人的消息，和针对自己的消息，并按照日期排序。

### 签到功能，信用管理

用户点击签到，服务器根据用户id，和订单信息和时间戳和UUID生成二维码，将对应得字符串放入redis中去，设置时效为1分钟。

管理员扫描二维码，如果提取二维码中得到订单信息，把订单设置为已签到状态，并记录签到时间。个人记录中有一个字段，记录着信用等级这一个字段，同时有一张rule(late, diff),里面有2个关键字段，第一个表示签到迟到了几分钟，第二个表示扣除的信用积分。设置一个定时任务，对于未签到的订单，一律扣除rule中对应late=0x7ffffffff的对应积分，默认60分以下将不能预定场馆。

# 自我介绍

我叫陈泰良，今年23岁，现在是南京大学软件学院电子信息专业的研究生一年级学生，对软件开发怀有浓厚的兴趣。学习之余我也会积极参加学校老师引导的项目练手，目前已经参与多个项目，如：基于微服务的危险废物管理系统，羽毛球场馆预定系统等等。但仍觉得自己经历甚浅，希望能通过实习，更多地与社会接触完成从学生到职业人员地蜕变。请考官多多指教，谢谢。