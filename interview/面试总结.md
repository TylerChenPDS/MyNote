# **计算机网络**

## 概述 

### 请写出网络7层模型OSI和TCP/IP分层模型

OSI分层模型 物理层，数据链路层，网络层，传输层，会话层，表示层，应用层

TCP/IP分层模型  网络接口层,网络层，传输层，应用层

## 运输层

### TCP建立连接的三次握手

![image-20210218195747846](https://gitee.com/CTLQAQ/picgo/raw/master/image-20210218195747846.png)

### 为什么tcp建立连接需要第三次握手

**防止已经失效的连接请求突然又传送到服务器，造成错误。**如果没有随后一次确认，假设一种异常情况：客户端A发送了一个连接请求，结果这个请求在某些节点滞留了，A长时间没收到响应，于是又发送一个请求。第二次请求得到了确认，于是建立连接，数据传输后，释放了连接。然后那个滞留的请求到了，于是又会建立一个连接，但是A不需要发送数据，服务器B却一直等待A发送数据，导致B的许多资源白白浪费了。





# 数据结构

# 操作系统

# 数据库

# JAVA语言

## 语言细节

### 按值传递和按引用传递的区别

官方的说法是在**java中只有按值传递，并没有所谓的按引用传递**。java数据类型可以分为两大类：基本类型（primitive types）和引用类型（reference types）。**引用类型的按值传递，传递的是对象的地址**

![image-20210124151337933](https://gitee.com/CTLQAQ/picgo/raw/master/image-20210124151337933.png)



### 面向对象的三大特性的理解

**封装**给对象提供了隐藏内部特性和行为的能力。 

**多态**性是允许你将父对象设置成为一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。父对象就可以根据实际类型来表先不同的行为。

**继承**提供了代码的重用性，也可以在不修改类的情况下给现存的类添加新特性。 

### JAVA异常

在 Java 中，所有的异常都有一个共同的祖先 `java.lang` 包中的 `Throwable` 类。`Throwable` 类有两个重要的子类 `Exception`（异常）和 `Error`（错误）。`Exception` 能被程序本身处理(`try-catch`)， `Error` 是无法处理的(只能尽量避免)。

### Java 序列化中如果有些字段不想进行序列化，怎么办？

对于不想进行序列化的变量，使用 transient 关键字修饰。

transient 关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被 transient 修饰的变量值不会被持久化和恢复。transient 只能修饰变量，不能修饰类和方法。

### 深拷贝VS浅拷贝

1. **浅拷贝**：对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝，此为浅拷贝。
2. **深拷贝**：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，此为深拷贝。



### == 和 equals 的区别

==：对于基本类型，它比较的是值，对于引用类型，它比较的是内存地址。

equals()的作用也是比较两个对象是否相等，但它一般有2种使用情况：

- 类如果没有覆盖equals()方法，则通过equals() 比较的的时候等价于“==”
- 第二种情况是我们可以自定义equals()的内容，判断两个对象的内容是否相等，例如对于People对象来说，如果其身份证号码相等我们就认为它是相等的。



### 类的 hashcode 是什么

**1)hashCode()介绍:**

`hashCode()` 的作用是获取哈希码，也称为散列码；它实际上是返回一个 int 整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。`hashCode()`定义在 JDK 的 `Object` 类中，这就意味着 Java 中的任何类都包含有 `hashCode()` 函数。另外需要注意的是： `Object` 的 hashcode 方法是本地方法，也就是用 c 语言或 c++ 实现的，该方法通常用来将对象的内存地址 转换为整数之后返回。

**2)为什么要有 hashCode？**

**因为在使用散列的时候，我们可以快速定位对象的位置**。当你把对象加入 `HashSet` 时，`HashSet` 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的 hashcode，`HashSet` 会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 `equals()` 方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，`HashSet` 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。



### 为什么重写 `equals` 时必须重写 `hashCode` 方法？

如果两个对象相等，则 hashcode 一定也是相同的。两个对象相等,对两个对象分别调用 equals 方法都返回 true。**但是，两个对象有相同的 hashcode 值，它们也不一定是相等的。因此，equals 方法被覆盖过，则 `hashCode` 方法也必须被覆盖。**否则，两个equals相等的对象的hashcode也会不一样（因为Object 里面的hashCode 使用的是native方法，是根据内存地址转换成正数得来的），这样在使用某些集合框架的时候可能会造成错误。



### 什么是泛型？

**Java泛型设计原则：只要在编译时期没有出现警告，那么运行时期就不会出现ClassCastException异常**.

泛型：**把类型明确的工作推迟到创建对象或调用方法的时候才去明确的特殊的类型**

- `ArrayList<E>`中的**E称为类型参数变量**
- `ArrayList<Integer>`中的**Integer称为实际类型参数**

没有泛型之前，集合框架是使用Object实现的，在集合种读取到的每一个对象都需要进行强制类型转化，如果不小心插入了类型错误的对象，只有在运行的时候才会发现错误。有了泛型之后，可以告诉编译器，每个集合种接收那些对象类型，并再编译时告知是否插入了错误的对象。



### c++ 和 java 的区别

- 都是面向对象的语言，都支持封装、继承和多态
- Java 不提供指针来直接访问内存，程序内存更加安全
- Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。
- Java 有自动内存管理机制，不需要程序员手动释放无用内存
- **在 C 语言中，字符串或字符数组最后都会有一个额外的字符‘\0’来表示结束。但是，Java 语言中没有结束符这一概念。**因为java中String是个对象，有长度的概念，已经不需要'\0'表示结尾

### 重载和重写的区别

**重载：**

发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。

**重写：**

重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。

1. 返回值类型、方法名、参数列表必须相同，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。
2. 如果父类方法访问修饰符为 `private/final/static` 则子类就不能重写该方法，但是被 static 修饰的方法能够被再次声明。
3. 构造方法无法被重写



### 为什么String是不可变的？

**可变性**

简单的来说：String 类中使用 final 关键字修饰字符数组来保存字符串，`private final char value[]`，所以 String 对象是不可变的。

> 补充（来自[issue 675](https://github.com/Snailclimb/JavaGuide/issues/675)）：在 Java 9 之后，String 类的实现改用 byte 数组存储字符串 `private final byte[] value`

### StringBuffer和StringBuilder的区别是什么？

StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串`char[]value` 但是没有用 final 关键字修饰，所以这两种对象都是可变的。

**线程安全性**

StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。

**性能**

相同情况下使用 StringBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。



## 集合框架

### HashMap 和 Hashtable 有什么区别？

HashMap 和 Hashtable 都实现了 Map 接口，因此很多特性非常相似。

不同点：

 1，HashMap 允许键和值是 null，key为null`的键值对永远都放在以`table`[0]为头结点的链表中。`而 Hashtable 不允许键或者值是 null。

2,Hashtable 是线程安全的，而 HashMap 不是，多线程环境下可以采用concurrent并发包下的concurrentHashMap。因此，HashMap 更适合于单线程环境，而 Hashtable 适合于多线程环境。



### HashSet 和 TreeSet 有什么区别？

HashSet 是由一个 hash 表来实现的，因此，它的元素是无序的。add()，remove()，contains() 方法的时间复杂度是 O(1)。

TreeSet 是由一个树形的结构来实现的，它里面的元素是有序的。因此，add()， remove()，contains()方法的时间复杂度是 O(logn)。



## JVM

### 介绍一下JAVA内存区域

1.8 之前

![image-20210125142015747](https://gitee.com/CTLQAQ/picgo/raw/master/image-20210125142015747.png)

1.8 

![image-20210125142426115](https://gitee.com/CTLQAQ/picgo/raw/master/image-20210125142426115.png)

**线程私有的：**

- 程序计数器
- 虚拟机栈
- 本地方法栈

**线程共享的：**

- 堆
- 方法区
- 直接内存(非运行时数据区的一部分)



**程序计数器**

程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。**字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完。**

主要作用：

- 实现代码的流程控制
- 现场恢复

**程序计数器是唯一一个不会出现 OutOfMemoryError 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。**



**Java虚拟机栈**

Java虚拟机栈也是线程私有的，它的**生命周期和线程相同**，**描述的是 Java 方法执行的内存模型**，每次方法调用的数据都是通过栈传递的。Java虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息。

**局部变量表主要存放了编译器可知的各种数据类型**（boolean、byte、char、short、int、float、long、double）、**对象引用**（reference类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。

**Java 虚拟机栈会出现两种异常：StackOverFlowError 和 OutOfMemoryError。**

**那么方法/函数如何调用？**

Java 栈中保存的主要内容是栈帧，每一次函数调用都会有一个对应的栈帧被压入Java栈，每一个函数调用结束后，都会有一个栈帧被弹出。

Java方法有两种返回方式：

1. return 语句。
2. 抛出异常。

不管哪种返回方式都会导致栈帧被弹出



**本地方法栈**

和虚拟机栈所发挥的作用非常相似，区别是： **虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。** 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。



**堆**	

ava 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。**此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。**

Java 堆是垃圾收集器管理的主要区域，因此也被称作**GC堆（Garbage Collected Heap）**.从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以Java堆还可以细分为：新生代和老年代：再细致一点有：Eden空间、From Survivor、To Survivor、Tenured ( 享有终身职位的 )。**进一步划分的目的是更好地回收内存，或者更快地分配内存。**

大部分情况，对象都会首先在 Eden 区域分配，在一次**新生代垃圾回收**后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加 1(Eden区->Survivor 区后对象的初始年龄变为1)，当它的年龄增加到一定程度（默认为15岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 `-XX:MaxTenuringThreshold` 来设置。



**方法区 / 永久代 / 元空间**

它用于存储**已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据**。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 **Non-Heap（非堆）**，目的应该是与 Java 堆区分开来。

补充: 方法区和永久代之间的关系

> 《Java虚拟机规范》只是规定了有方法区这么个概念和它的作用，并没有规定如何去实现它。那么，在不同的 JVM 上方法区的实现肯定是不同的了。 **方法区和永久代的关系很像Java中接口和类的关系，类实现了接口，而永久代就是HotSpot虚拟机对虚拟机规范中方法区的一种实现方式。** 也就是说，永久代是HotSpot的概念，方法区是Java虚拟机规范中的定义，是一种规范，而永久代是一种实现，

JDK 1.8 之前永久代还没被彻底移除的时候通常通过下面这些参数来调节方法区大小

> -XX:PermSize=N //方法区(永久代)初始大小 
>
> -XX:MaxPermSize=N //方法区(永久代)最大大小,超过这个值将会抛出OutOfMemoryError异常:java.lang.OutOfMemoryError: PermGen

JDK 1.8 的时候，方法区（HotSpot的永久代）被彻底移除了（JDK1.7就已经开始了），取而代之是元空间，**元空间使用的是直接内存**。与永久代很大的不同就是，如果不指定大小的话，随着更多类的创建，虚拟机会耗尽所有可用的系统内存。

> -XX:MetaspaceSize=N //设置Metaspace的初始（和最小大小）
>
> -XX:MaxMetaspaceSize=N //设置Metaspace的最大大小



**b**

运行时常量池是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池信息（用于存放编译期生成的各种字面量和符号引用）**JDK1.7及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。**

![image-20210125145959544](https://gitee.com/CTLQAQ/picgo/raw/master/image-20210125145959544.png)



### 

**直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 异常出现。**

## NIO/BIO/AIO

### BIO、NIO、AIO 概念和区别

**BIO**

BIO又被称为阻塞式I/O模型。多线程的BIO中 ，客户端有连接请求时服务器端就需要启动一个线程进行处理。但是随着客户端的增多，服务端的线程数膨胀，系统性能急剧下降，最终会导致系统不可用。这种模型无法满足高并发，高性能的场景。

```java
public class SocketServer {
    public static void main(String[] args) throws IOException {
        ServerSocket serverSocket = new ServerSocket(9000);
        while (true) {
            System.out.println("等待连接。。");
            //阻塞方法
            Socket clientSocket = serverSocket.accept();
            System.out.println("有客户端连接了。。");
            handler(clientSocket);

            /*new Thread(new Runnable() {
                @Override
                public void run() {
                    try {
                        handler(clientSocket);
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                }
            }).start();*/
        }
    }

    private static void handler(Socket clientSocket) throws IOException {
        byte[] bytes = new byte[1024];
        System.out.println("准备read。。");
        //接收客户端的数据，阻塞方法，没有数据可读时就阻塞
        int read = clientSocket.getInputStream().read(bytes);
        System.out.println("read完毕。。");
        if (read != -1) {
            System.out.println("接收到客户端的数据：" + new String(bytes, 0, read));
        }
        clientSocket.getOutputStream().write("HelloClient".getBytes());
        clientSocket.getOutputStream().flush();
    }
}
```



**NIO (Non-blocking/New I/O)**

同步非阻塞，服务器实现模式为**一个线程可以处理多个请求(连接)**，客户端发送的连接请求都会注册到**多路复用器selector**上,  多路复用器轮询到连接有IO请求就进行处理。

**应用场景：**

NIO方式适用于连接数目多且连接比较短（轻操作） 的架构， 比如聊天服务器， 弹幕系统， 服务器间通讯，编程比较复杂

**NIO引入多路复用器代码示例：**

```java
public class NioSelectorServer {

    public static void main(String[] args) throws IOException, InterruptedException {

        // 创建NIO ServerSocketChannel
        ServerSocketChannel serverSocket = ServerSocketChannel.open();
        serverSocket.socket().bind(new InetSocketAddress(9000));
        // 设置ServerSocketChannel为非阻塞
        serverSocket.configureBlocking(false);
        // 打开Selector处理Channel，即创建epoll
        Selector selector = Selector.open();
        // 把ServerSocketChannel注册到selector上，并且selector对客户端accept连接操作感兴趣
        serverSocket.register(selector, SelectionKey.OP_ACCEPT);
        System.out.println("服务启动成功");

        while (true) {
            // 阻塞等待需要处理的事件发生
            selector.select();

            // 获取selector中注册的全部事件的 SelectionKey 实例
            Set<SelectionKey> selectionKeys = selector.selectedKeys();
            Iterator<SelectionKey> iterator = selectionKeys.iterator();

            // 遍历SelectionKey对事件进行处理
            while (iterator.hasNext()) {
                SelectionKey key = iterator.next();
                // 如果是OP_ACCEPT事件，则进行连接获取和事件注册
                if (key.isAcceptable()) {
                    ServerSocketChannel server = (ServerSocketChannel) key.channel();
                    SocketChannel socketChannel = server.accept();
                    socketChannel.configureBlocking(false);
                    // 这里只注册了读事件，如果需要给客户端发送数据可以注册写事件
                    socketChannel.register(selector, SelectionKey.OP_READ);
                    System.out.println("客户端连接成功");
                } else if (key.isReadable()) {  // 如果是OP_READ事件，则进行读取和打印
                    SocketChannel socketChannel = (SocketChannel) key.channel();
                    ByteBuffer byteBuffer = ByteBuffer.allocate(128);
                    int len = socketChannel.read(byteBuffer);
                    // 如果有数据，把数据打印出来
                    if (len > 0) {
                        System.out.println("接收到消息：" + new String(byteBuffer.array()));
                    } else if (len == -1) { // 如果客户端断开连接，关闭Socket
                        System.out.println("客户端断开连接");
                        socketChannel.close();
                    }
                }
                //从事件集合里删除本次处理的key，防止下次select重复处理
                iterator.remove();
            }
        }
    }
}
```

上面函数的调用过程：

**首先，会调用系统调用epoll_create创建epoll实例，然后把，ServerSocketChannel 加入到一个集合，再然后调用epoll_ctl() 为其绑定事件ACCEPT，然后调用selector.select() ，这个方法会调用epoll_wait(), 当Socket收到数据的时候，OS会通过中断机制，把对应的socket引用加入到epoll实例的就绪列表中。此时可以根据事件，做出不同的操作，如果是ACCEPT事件，则需要获得对应的ServerSocketChannel ，并调用其Socket方法，获得SocketChannel, 把新的到的SocketChannel 注册到多路复用器上，绑定事件READ（即服务器接收来自客户端的数据）。**

**此时如果客户端发送数据，那么服务器Socket收到数据后，OS启动中断机制，把对应的socket（就是SocketChannel）加入epoll实例的就绪列表中，然后遍历对其进行处理。**

| java                                                     | linux内核方法                            |
| -------------------------------------------------------- | ---------------------------------------- |
| Selector.open();                                         | 调用epoll_create                         |
| selector.select();                                       | epoll_wait()，阻塞等待需要处理的事件发生 |
| serverSocket.register(selector, SelectionKey.OP_ACCEPT); | 调用epoll_ctl() 为其绑定事件ACCEPT       |

NIO 有三大核心组件： **Channel(通道)， Buffer(缓冲区)，Selector(多路复用器)**

1、channel 类似于流，每个 channel 对应一个 buffer缓冲区，buffer 底层就是个数组

2、channel 会注册到 selector 上，由 selector 根据 channel 读写事件的发生将其交由某个空闲的线程处理

3、NIO 的 Buffer 和 channel 都是既可以读也可以写

**AIO**

AIO 也就是 NIO 2。Java 7 中引入了 NIO 的改进版 NIO 2,它是异步 IO 模型。

异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。

目前来说 AIO 的应用还不是很广泛。Netty 之前也尝试使用过 AIO，不过又放弃了。这是因为，Netty 使用了 AIO 之后，在 Linux 系统上的性能并没有多少提升。

AIO代码示例：

```java
public class AIOServer {

    public static void main(String[] args) throws Exception {
        final AsynchronousServerSocketChannel serverChannel =
                AsynchronousServerSocketChannel.open().bind(new InetSocketAddress(9000));

        serverChannel.accept(null, new CompletionHandler<AsynchronousSocketChannel, Object>() {
            @Override
            public void completed(AsynchronousSocketChannel socketChannel, Object attachment) {
                try {
                    System.out.println("2--"+Thread.currentThread().getName());
                    // 再此接收客户端连接，如果不写这行代码后面的客户端连接连不上服务端
                    serverChannel.accept(attachment, this);
                    System.out.println(socketChannel.getRemoteAddress());
                    ByteBuffer buffer = ByteBuffer.allocate(1024);
                    socketChannel.read(buffer, buffer, new CompletionHandler<Integer, ByteBuffer>() {
                        @Override
                        public void completed(Integer result, ByteBuffer buffer) {
                            System.out.println("3--"+Thread.currentThread().getName());
                            buffer.flip();
                            System.out.println(new String(buffer.array(), 0, result));
                            socketChannel.write(ByteBuffer.wrap("HelloClient".getBytes()));
                        }

                        @Override
                        public void failed(Throwable exc, ByteBuffer buffer) {
                            exc.printStackTrace();
                        }
                    });
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }

            @Override
            public void failed(Throwable exc, Object attachment) {
                exc.printStackTrace();
            }
        });

        System.out.println("1--"+Thread.currentThread().getName());
        Thread.sleep(Integer.MAX_VALUE);
    }
}
```



## 多线程

### 为什么要使用多线程？

线程可以比作是轻量级的进程，是程序执行的最小单位,线程间的切换和调度的成本远远小于进程。另外，多核 CPU 时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。

有了多线程之后，进程是资源调度的基本单位，而线程是处理机调度的基本单位。



https://blog.csdn.net/TZ845195485/article/details/109210263

### 什么情况下使用线程池？

1.单个任务处理的时间比较短
2.将需处理的任务的数量大

### 实现线程池的好处？

- 1.降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。
- 2.提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。
- 3.提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。

### 使用 Executors 的工厂方法创建线程

- newCachedThreadPool：

  创建一个可缓存线程池

  优点：很灵活，弹性的线程池线程管理，用多少线程给多大的线程池，不用后及时回收，用则新建

  缺点：一旦线程无限增长，会导致内存溢出。

- newFixedThreadPool ：

  优点：创建一个固定大小线程池，超出的线程会在队列中等待。

  缺点：不支持自定义拒绝策略，大小固定，难以扩展

- newScheduledThreadPool ：

  优点：创建一个固定大小线程池，可以定时或周期性的执行任务。

  缺点：任务是单线程方式执行，一旦一个任务失败其他任务也受影响

- newSingleThreadExecutor ：

  优点：创建一个单线程的线程池，保证线程的顺序执行

  缺点：不适合并发。。

- **统一缺点：**不支持自定义拒绝策略

Executors 返回的线程池对象的弊端如下： 

1） FixedThreadPool 和 SingleThreadPool: 

允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。 

2） CachedThreadPool 和 ScheduledThreadPool: 

允许的创建线程数量为 Integer.MAX_VALUE， 可能会创建大量的线程，从而导致 OOM。



### BlockingQueue 

一个阻塞队列，**用来存储等待执行的任务**，常用的有如下几种：
**ArrayBlockingQueue**：是一个基于数组结构的有界阻塞队列，此队列按 FIFO（先进先出）原则对元素进行排序。
**LinkedBlockingQueue**：一个基于链表结构的阻塞队列，此队列按FIFO （先进先出） 排序元素，吞吐量通常要高于	
**ArrayBlockingQueue**。静态工厂方法Executors.newFixedThreadPool()使用了这个队列。
**SynchronousQueue**：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQueue，静态工厂方法Executors.newCachedThreadPool使用了这个队列。
**PriorityBlockingQueue**：一个具有优先级得无限阻塞队列。



如果阻塞队列满了，需要用到拒绝策略

RejectedExecutionHandler : 当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。有下面四种JDK提供的策略：
**AbortPolicy**，表示无法处理新任务时抛出异常, 默认策略
**CallerRunsPolicy**：用调用者所在线程来运行任务。
**DiscardOldestPolicy**： 该策略将丢弃最老的一个请求，也就是丢弃即将被执行的任务，并尝试再次提交当前任务。
**DiscardPolicy**：不处理，丢弃掉 
除了这些JDK提供的策略外，还可以自己实现 RejectedExecutionHandler 接口定义策略。



### Java 怎么保证多线程的安全

1. 使用volatile( 不稳定的、反复无常的)，或者 synchronized关键字解决内存可见性问题。
2. 可以使用锁机制，synchronized，和CAS来解决原子性问题
3. 可以使用信号量机制解决同步问题。

### JAVA内存模型

- 所有的变量都存储在主内存中（**操作系统给进程分配的内存空间**）
- **每个线程都有自己独立的工作内存，里面保存该线程使用到的变量的副本**

![image-20210126160641338](https://gitee.com/CTLQAQ/picgo/raw/master/image-20210126160641338.png)

- 线程对共享变量的所有操作都必须在自己的工作内存（working memory,是cache和寄存器的一个抽象，而并不是内存中的某个部分）**不同线程之间，当前线程无法直接访问其他线程的工作内存中的变量，线程间变量值得传递需要通过主内存来完成**

**共享变量可见性的实现原理**

- **把工作内存1中更新过的共享变量刷新到主内存中**
- **将主内存中最新的共享变量的值更新到工作内存2中**

### 内存可见性

**内存可见性其实就是共享变量在线程间的可见性**

- **共享变量**：如果一个变量在多个线程的工作内存中都存在**副本**，那么这个变量就是这几个线程的共享变量
- **可见性**：一个线程对共享变量值的修改，能够及时的被其他线程看到

```java
public class TestVolatile {
    public static void main(String[] args) {
        ThreadDemo td = new ThreadDemo();
        new Thread(td).start();
        while(true){
            if(td.isFlag()){
                System.out.println("--------主线中的程序读到flag为true了----------");
                break;
            }
//这里不能有语句，有语句循环之间就有间隙
        }
    }
}

class ThreadDemo implements Runnable {
    private boolean flag = false;
    //private volatile boolean flag = false; 加上volatile之后，程序可以正常终止
    @Override
    public void run() {
        try {
            Thread.sleep(200);
        } catch (InterruptedException e) {
        }
        flag = true;
        System.out.println("flag=" + isFlag());
    }
    public boolean isFlag() {
        return flag;
    }
    public void setFlag(boolean flag) {
        this.flag = flag;
    }
}
```

主内存中存在flag = false，线程td启动后，将flag = false，放到自己的工作内存中，然后睡眠1秒，这期间，（因为要使用）主线程也把flag = false放到自己的工作内存放到自己的工作空间。td线程把flag = true由刷新到主内存中，但是主线程工作空间内的flag还是false。也就是说，td对共享变量的修改对主线程“不可见了”。所以上面的线程不会停止。

### 解决内存可见性的方法

使用volatile之后，td将更改刷到主存中后，会告知main线程

使用**synchronized**

JMM关于synchronized的两条规定：

- **线程解锁前，必须把共享变量的最新值刷新到主内存中**
- **线程加锁时，将清空工作内存中共享变量的值，从而使用共享变量时需要从主内存中重新读取最新的值** 



### **synchronized和volatile比较**

- volatile不需要加锁，比synchronized更轻量级，不会阻塞线程，效率更高

- volatile不具备“互斥性”，synchronized就具备“互斥性”

  - 何为互斥性？

    比方说当我们用synchronize修饰方法，

    当一个线程抢到锁执行该方法后另一个线程无法再抢到锁执行该方法

- synchronized既能保证可见性，又能保证原子性，而volatile只能保证可见性，不能保证原子性。

- 如果能用volatile解决问题，还是应尽量使用volatile，因为它的效率更高 



### 原子性

经典不具有原子性的操作,包括读取变量的原始值、进行加1操作、写入工作内存

```java
public int getSerialNumber(){
    return serialNumber++; //这个操作不具有原子性；
}
```

里边封装了一系列常用的数据类型对应的封装类，

Java.util.concurrent.atomic中实现的原子操作类包括：

AtomicBoolean、AtomicInteger、AtomicLong、AtomicReference。

**这些类都保证了两点：**

- **类里的变量都用了volatile保证内存是可见的**
- 使用了一个算法**CAS**，保证对这些数据的操作具有原子性

### CAS （Compare and Swap）

- **悲观锁：传统的锁机制**，例如 java 的 synchronized 关键字，他代表了 java 中悲观锁技术，保证了某一时刻仅有一个线程能访问同步代码/方法。synchronized 能够很好地工作，却有着 (相对) 比较大的性能开销。
- **乐观锁** (相对悲观锁) 对性能会有很大的帮助。他的核心思想是：寄希望于在没有冲突的情况下完成一次更新操作，使用乐观锁技术更新时会进行 “冲突检测” 来判断是否有其他的线程干扰，若是 (有其他线程干扰) 则视本次更新操作失败，一般会进行重试。
- Compare and Swap 就是典型的乐观锁技术

**CAS是通过硬件命令保证了原子性 ** CAS有3个操作数，**内存值V，旧的预期值A，要修改的新值B**。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则返回V。

就是指当V和A两者进行比较时，如果相等，则证明共享数据没有被修改，替换成新值，然后继续往下运行；如果不相等，说明共享数据已经被修改，放弃已经所做的操作，然后重新执行刚才的操作。这样子，就能保证操作的原子性了。

栗子：

![image-20210126162533637](https://gitee.com/CTLQAQ/picgo/raw/master/image-20210126162533637.png)

例如：t1，t2线程是同时更新同一变量56的值。因为t1和t2线程都同时去访问同一变量值56，所以他们会把主内存的值完全拷贝一份到自己的工作内存空间，所以t1和t2线程的预期值都为56。假设此时t1 竞争到了CPU，t1的旧的预期值为56 与内存值56相等，于是它可以把共享变量修改成57。 此时t2 又竞争到了CPU，t2的预期值与主内存中的不一样，所以他就要放弃此次修改，然后重试。

### JUC强大的三个工具类

CountDownLatch | CyclicBarrier | Semaphore 底层都是AQS来实现的

**CountDownLatch(闭锁)**

- CountDownLatch主要有两个方法，当一个或多个线程调用await方法时，这些线程会阻塞
- 其它线程调用countDown方法会将计数器减1(调用countDown方法的线程不会阻塞)
- 计数器的值变为0时，因await方法阻塞的线程会被唤醒，继续执行

栗子:  要求6个线程都执行完了,mian线程最后执行

```java

public class CountDownLatchDemo {
    public static void main(String[] args) throws Exception{

        CountDownLatch countDownLatch=new CountDownLatch(6);
        for (int i = 1; i <=6; i++) {
            new Thread(()->{
                System.out.println(Thread.currentThread().getName()+"\t");
                countDownLatch.countDown();
            },i+"").start();
        }
        countDownLatch.await();
        System.out.println(Thread.currentThread().getName()+"\t班长关门走人，main线程是班长");
    }
}
```

**CyclicBarrier**

CyclicBarrier的字面意思是可循环(Cyclic) 使用的屏障(barrier).它要做的事情是,让一组线程到达一个屏障(也可以叫做同步点)时被阻塞,直到最后一个线程到达屏障时,屏障才会开门,所有被屏障拦截的线程才会继续干活,线程进入屏障通过CyclicBarrier的await()方法

```java
    //集齐7颗龙珠就能召唤神龙
	public class CyclicBarrierDemo {
	    public static void main(String[] args) {
	        // public CyclicBarrier(int parties, Runnable barrierAction) {}
	        CyclicBarrier cyclicBarrier=new CyclicBarrier(7,()->{
	            System.out.println("召唤龙珠");
	        });
	        for (int i = 1; i <=7; i++) {
	            final int temp=i;
	            new Thread(()->{
	                System.out.println(Thread.currentThread().getName()+"\t收集到了第"+temp+"颗龙珠");
	                try {
	                    cyclicBarrier.await();
	                } catch (InterruptedException e) {
	                    e.printStackTrace();
	                } catch (BrokenBarrierException e) {
	                    e.printStackTrace();
	                }
	            }).start();
	        }
	
	    }
	}

```

**Semaphore(信号量)**

- ①. acquire（获取） 当一个线程调用acquire操作时，它要么通过成功获取信号量（信号量减1），要么一直等下去，直到有线程释放信号量，或超时。
- ②. release（释放）实际上会将信号量的值加1，然后唤醒等待的线程。
- ③. 信号量主要用于两个目的，一个是用于多个共享资源的互斥使用，另一个用于并发线程数的控制。





### 线程按序交替ABC

编写一个程序，开启三个线程，这三个线程的ID分别为A、B、C，每个线程将自己的ID在屏幕上打印10遍，要求输出的结果必须按顺序显示，如:ABCABCABC……

方法1，使用信号量机制

```java
public class ABCThread {
	public static void main(String[] args) {
		Semaphore printA = new Semaphore(1);
		Semaphore printB = new Semaphore(0);
		Semaphore printC = new Semaphore(0);
		new Thread(()->{
			for(int i = 0; i < 10; i ++){
				try {
					printA.acquire();
					System.out.println("A");
					printB.release();
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
			}
		}).start();
		new Thread(()->{
			for(int i = 0; i < 10; i ++){
				try {
					printB.acquire();
					System.out.println("B");
					printC.release();
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
			}
		}).start();
		new Thread(()->{
			for(int i = 0; i < 10; i ++){
				try {
					printC.acquire();
					System.out.println("C");
					printA.release();
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
			}
		}).start();
	}
}
```

### Synchronized 的底层实现

https://www.jianshu.com/p/c97227e592e1

![image-20210127175442004](https://gitee.com/CTLQAQ/picgo/raw/master/image-20210127175442004.png)

![image-20210127175528382](https://gitee.com/CTLQAQ/picgo/raw/master/image-20210127175528382.png)

`synchronized`修饰的方法在字节码中添加了一个`ACC_SYNCHRONIZED`的flags,同步代码块则是在同步代码块前插入`monitorenter`，在同步代码块结束后插入`monitorexit`。

这两者的处理是分别是这样的：当线程执行到某个方法时，JVM会去检查该方法的`ACC_SYNCHRONIZED`访问标志是否被设置，如果设置了那线程会去获取这个对象所对应的`monitor`对象（每一个对象都有且仅有一个与之对应的`monitor`对象）,获取成功后才执行方法体，方法执行完再释放`monitor`对象，在这一期间，任何其他线程都无法获得这个`monitor`对象

而线程执行同步代码块时遇到的`monitorenter`和`monitorexit`指令依赖`monitor`对象完成。这两者实现的方式本质上无区别，只是方法的同步是一种隐式的方式，不通过字节码实现。



1. 每个锁对象拥有一个锁计数器和一个指向持有该锁的线程的指针
2. 当执行monitorenter时,如果目标锁对象的计数器为零,那么说明它没有被其他线程持有,Java虚拟机会将该锁对象的持有线程设置为当前线程,并且将其计数器加1,否则需要等待,直至持有线程释放该锁
3. 当执行monitorexit时,Java虚拟机则锁对象的计数器减1。计数器为零代表锁已经被释放

### AQS 是什么

AQS 是一个用来构建锁和同步器的框架，使用 AQS 能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的 `ReentrantLock`，`Semaphore`，其他的诸如 `ReentrantReadWriteLock`，`SynchronousQueue`，`FutureTask` 等等皆是基于 AQS 的。当然，我们自己也能利用 AQS 非常轻松容易地构造出符合我们自己需求的同步器。

### AQS 原理

**AQS 核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用 CLH 队列锁实现的，即将暂时获取不到锁的线程加入到队列中。**

AQS 使用一个 int 成员变量来表示同步状态，通过内置的 FIFO 队列来完成获取资源线程的排队工作。AQS 使用 CAS 对该同步状态进行原子操作实现对其值的修改。

**AQS 定义两种资源共享方式**

- Exclusive

  （独占）：只有一个线程能执行，如ReentrantLock

  又可分为公平锁和非公平锁：

  - 公平锁：按照线程在队列中的排队顺序，先到者先拿到锁
  - 非公平锁：当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的

- **Share**（共享）：多个线程可同时执行，如`CountDownLatch`、`Semaphore`、`CountDownLatch`、 `CyclicBarrier`、`ReadWriteLock` 我们都会在后面讲到。

**AQS底层是使用了模板方法**

同步器的设计是基于模板方法模式的，如果需要自定义同步器一般的方式是这样（模板方法模式很经典的一个应用）：

1. 使用者继承 `AbstractQueuedSynchronizer` 并重写指定的方法。（这些重写方法很简单，无非是对于共享资源 state 的获取和释放）
2. 将 AQS 组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。

这和我们以往通过实现接口的方式有很大区别，这是模板方法模式很经典的一个运用。

**AQS 使用了模板方法模式，自定义同步器时需要重写下面几个 AQS 提供的模板方法：**

```java
isHeldExclusively()//该线程是否正在独占资源。只有用到condition才需要去实现它。
tryAcquire(int)//独占方式。尝试获取资源，成功则返回true，失败则返回false。
tryRelease(int)//独占方式。尝试释放资源，成功则返回true，失败则返回false。
tryAcquireShared(int)//共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。
tryReleaseShared(int)//共享方式。尝试释放资源，成功则返回true，失败则返回false。
```

以 ReentrantLock 为例，state 初始化为 0，表示未锁定状态。A 线程 lock()时，会调用 tryAcquire()独占该锁并将 state+1。此后，其他线程再 tryAcquire()时就会失败，直到 A 线程 unlock()到 state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A 线程自己是可以重复获取此锁的（state 会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证 state 是能回到零态的。



再以 `CountDownLatch` 以例，任务分为 N 个子线程去执行，state 也初始化为 N（注意 N 要与线程个数一致）。这 N 个子线程是并行执行的，每个子线程执行完后`countDown()` 一次，state 会 CAS(Compare and Swap)减 1。等到所有子线程都执行完后(即 state=0)，会 unpark()主调用线程，然后主调用线程就会从 `await()` 函数返回，继续后余动作。



一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现`tryAcquire-tryRelease`、`tryAcquireShared-tryReleaseShared`中的一种即可。但 AQS 也支持自定义同步器同时实现独占和共享两种方式，如`ReentrantReadWriteLock`。



# 微服务架构

## 基本概念

### 微服务的优缺点

优点：

1，技术异构性：在一个由多个服务相互协作的系统中，可以在不同的服务中使用最适合该服务的技术。

2，弹性：如果系统中的一个组件不可用了，但并没有导致级联故障，那么系统的其他部分还可以正常运行。

3，扩展：可以只对那些需要扩展的服务进行扩展。

4，简化部署：各个服务的部署是独立的，这样就可以更快地对特定部分的代码进行部署。

5，与组织结构相匹配：可以很好地将架构与组织结构相匹配，避免出现过大的代码库，从而获得理想团队大 小及生产力。

  6，可组合性：不同服务模块的接口可以再进行重用，成为其他产品中的一个组件；

  7，对可替代性的优化：可以在需要时轻易地重写服务，或者删除不再使用的服务

缺点：

1，运维开销 更多的服务也就意味着更多的运维

  2，隐式接口 服务和服务之间通过接口来“联系”，当某一个服务更改接口格式时，可能涉及到此接口的所有服 务都需要做调整。

  3，重复劳动 在很多服务中可能都会使用到同一个功能，而这一功能点没有足够大到提供一个服务的程度，这 个时候可能不同的服务团队都会单独开发这一功能，重复的业务逻辑

  4，分布式系统的复杂性 微服务通过REST API或消息来将不同的服务联系起来，这在之前可能只是一个简单的 远程过程调用。分布式系统也就意味着开发者需要考虑网络延迟、容错、消息序列化、不可靠的网络、异 步、版本控制、负载等，而面对如此多的微服务都需要分布式时，整个产品需要有一整套完整的机制来保 证各个服务可以正常运转。

  5，事务、异步、测试面临挑战 跨进程之间的事务、大量的异步处理、多个微服务之间的整体测试都需要有一 整套的解决方案，而现在看起来，这些技术并没有特别成熟。



## 基础设施

### Nacos简介 注册中心

![image-20210128134338070](https://gitee.com/CTLQAQ/picgo/raw/master/image-20210128134338070.png)



nacos维护一个注册中心。注册中心提供的功能主要有：**服务注册，心跳检测，和服务发现**。当各个微服务启动的时候都要向注册中心注册自己的信息（服务名，IP地址，端口号， 状态， 上次更新时间等）。当某个服务上线的时候需要调用nacos server 的注册接口，nacos server向数据库中插入该微服务的注册信息， 状态为up。已经注册的微服务需要开启一个定时任务，定时调用nacos server的心跳接口，实际上就是修改数据库中对应服务的last_heart_time。注册中心启动的时候，也要开启一个定时任务，实际上就是拿当前时间和注册表中各记录的last_heart_time进行比较，如果上次心跳时间与当前时间的时间间隔过长则nacos server 会将对应的记录的状态改为down，代表该机器暂时不可用。需要调用其他微服务的模块会开启一个定时任务定时调用nacos server的服务获取接口，将所有状态为up的微服务信息记录拉取下来，并通过某种负载均衡策略调用该微服务。当某个微服务下线的时候，调用nacos server 的注销接口，nacos server便会将对应的记录剔除。

### 微服务为什么需要网关

1. 易于监控。可在微服务网关收集监控数据并将其推送到外部系统进行分析。

2. 易于认证。可在微服务网关上进行认证。然后再将请求转发到后端的微服务，而无须在每个微服务中进行认证。

3. 减少了客户端与各个微服务之间的交互次数。





# 常用框架

## JAVAWEB

### 什么是cookie？Session和Cookie有什么区别？

cookie 是 Web 服务器发送给浏览器的一块信息。浏览器会在本地文件中给每一个 Web 服务器存储 cookie。以后浏览器在给特定的 Web 服务器发请求的时候，同时会发送所有为该服务器存储的 cookie。

无论客户端浏览器做怎么样的设置，session都应该能正常工作。客户端可以选择禁用cookie， 但是，session 仍然是能够工作的，因为客户端无法禁用服务端的 session。 在存储的数据量方面 session 和 cookies 也是不一样的。session 能够存储任意的 Java 对象， cookie 只能存储 String 类型的对象。

### jsp隐含对象

JSP 隐含对象是页面中的一些 Java 对象，JSP 容器让这些 Java 对象可以为开发者所使用。开 发者不用明确的声明就可以直接使用他们。JSP 隐含对象也叫做预定义变量。application page request response session exception out config pageContext

### 谈一谈AJAX技术

 Ajax 的原理简单来说通过 XmlHttpRequest 对象来向服务器发异步请求，从服务器获得数据，然后用 javascript 来操作 DOM 而更新页面的局部显示。

   ajax的优点：

  1.最大的一点是页面无刷新，给用户的体验非常好。

  2.使用异步方式与服务器通信，不需要打断用户操作，具有更加迅速的响应能力。

  3.ajax 的原则是“按需取数据”，最大程度的减少冗余请求，减少服务器的负荷

### HTTP请求的GET与POST方式的区别

1. 携带请求参数的方式

GET: 通过请求行携带参数, 参数会显示在地址栏

POST: 通过请求体来携带参数, 参数不会显示在地址栏

2. 服务器端处理请求的方法

GET: 会调用 Servlet 的 doGet()来处理请求

POST: 会调用 Servlet 的 doPost()来处理请求 

3. 数据大小与安全性 

GET: 大小有限制(小于 2k), 不安全

POST: 大小没有限制, 安全





## Spring

### 简述AOP和IOC的概念

**AOP（Aspect Oriented Programming），即面向切面编程**

**例如日志功能。日志代码往往横向地散布在所有对象层次中，这种散布在各处的与具体业务无关的代码被称为横切**（cross cutting）

AOP把软件系统分为两个部分：**核心关注点和横切关注点**。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处基本相似，比如**权限认证、日志、事务**。**AOP的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来**

**控制反转**（Inversion of Control，缩写为**IoC**），可以用来减低计算机代码之间的[耦合度](https://baike.baidu.com/item/耦合度)。其中最常见的方式叫做**依赖注入**（Dependency Injection，简称**DI**）。**控制反转**是把传统上由程序代码直接操控的对象的调用权交给容器，**通过容器来实现对象组件的装配和管理**。



## SpringMVC

### 请谈一下Spring MVC的工作原理是怎样的？

1，客户端的所有请求都交给前端控制器DispatcherServlet来处理，它会负责调用系统的其他模块来真正处理用户的请求。

2， DispatcherServlet收到请求后，将根据请求的信息（包括URL、HTTP协议方法、请求头、请求参数、Cookie等）以及HandlerMapping的配置找到处理该请求的Handler（任何一个对象都可以作为请求的Handler）。

3，在这个地方Spring会通过HandlerAdapter对该处理器进行封装。

4， HandlerAdapter是一个适配器，它用统一的接口对各种Handler中的方法进行调用。

5， Handler完成对用户请求的处理后，会返回一个ModelAndView对象给DispatcherServlet，ModelAndView顾名思义，包含了数据模型以及相应的视图的信息。

6， ModelAndView的视图是逻辑视图，DispatcherServlet还要借助ViewResolver完成从逻辑视图到真实视图对象的解析工作。

7，当得到真正的视图对象后，DispatcherServlet会利用视图对象对模型数据进行渲染。
 8，客户端得到响应，可能是一个普通的HTML页面，也可以是XML或JSON字符串，还可以是一张图片或者一个PDF文件。

## MyBatis



# 设计模式