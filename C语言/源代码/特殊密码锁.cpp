#include <memory>
#include <string>
#include <cstring>
#include <iostream>
using namespace std;
/*
描述
	有一种特殊的二进制密码锁，由n个相连的按钮组成（n<30），按钮有凹/凸两种状态，用手按按钮会改变其状态。
	然而让人头疼的是，当你按一个按钮时，跟它相邻的两个按钮状态也会反转。当然，如果你按的是最左或者最右边的按钮，
	该按钮只会影响到跟它相邻的一个按钮。
	当前密码锁状态已知，需要解决的问题是，你至少需要按多少次按钮，才能将密码锁转变为所期望的目标状态。
输入
	两行，给出两个由0、1组成的等长字符串，表示当前/目标密码锁状态，其中0代表凹，1代表凸。
输出
	至少需要进行的按按钮操作次数，如果无法实现转变，则输出impossible。
样例输入
	011
	000
样例输出  
	1
	
样例输入
    011010
    100000
样例输出  
	4
思路： 
	只需要枚举第一个密码是否按下就可以了，然后从第一位开始判断，如果第一位不同则需要修改第二位的状态达到改变第一位的目的，
	然后判断第二位是否相同，一次类推。直到最后2位，如果最后2位都相同，则结束。如果倒数第二位不相同，则按下最后一位，然后判断最后
	一位是否相同，如果相同则结束，如果不同，则此次尝试失败。
	
	第一个是否按下会影响第二个密码是否按下，当第一个按下了，
	第二个密码会随之改变，当第一个不按，第二个密码的状态就不会改变，
	然后再看第二个密码的是否与目标密码的第二位一致，如果不一致，需要按下第三个按钮，
	如果一致，就不需要按下第三个按钮，这样循环到末尾，看看是否最后得到的密码与目标密码一致，如果一致，就更新最小值。 
*/
void reverse(char or1[30], int index){
	if(or1[index] == '0'){
		or1[index] = '1';
	}else{
		or1[index] = '0';
	}
}
int main(){
	char in[2][30];
	gets(in[0]);
	gets(in[1]);
	int len = strlen(in[0]);
	int a = 1; //如果第一次按钮按下，安的次数 
	int b = 0;
	//当第一按钮按下时，需要改变 第二个按钮的状态位 
	char cu[30];
	memcpy(cu, in[0], sizeof(cu));
	reverse(cu, 1);
	reverse(cu, 0);
	int i;
	for(i = 0; i < len - 2; i ++){
		if(cu[i] == in[1][i]){ //从0开始，如果第一位与目标第一位一样则不需要按下第二位 
			continue;
		}else{ //如果一样则需要按下下一位 
			a ++;
			reverse(cu,i + 1);
			reverse(cu,i + 2);
		} 
	}
	//现在剩最后2位了，
	if(cu[i] == in[1][i] && cu[i + 1] != in[1][i + 1]){
		a = 31;// 因为最多按30次，31次表示不可能 
	} else	if(cu[i] != in[1][i]){
		reverse(cu, i + 1);
		a ++;
		if(cu[i + 1] != in[1][i + 1]){
			a = 31;
		}
	} 
	
	//当第一个按钮不按下时
	memcpy(cu, in[0], sizeof(cu));
	for(i = 0; i < len - 2; i ++){
		if(cu[i] == in[1][i]){ //从0开始，如果第一位与目标第一位一样则不需要按下第二位 
			continue;
		}else{ //如果一样则需要按下下一位 
			b ++;
			reverse(cu,i + 1);
			reverse(cu,i + 2);
		} 
	}
	//现在剩最后2位了，
	if(cu[i] == in[1][i] && cu[i + 1] != in[1][i + 1]){
		b = 31;// 表示不可能 
	} else	if(cu[i] != in[1][i]){
		reverse(cu, i + 1);
		b ++;
		if(cu[i + 1] != in[1][i + 1]){
			b = 31;
		}
	} 
	int res = a < b ? a : b;
	if(res == 31){
		cout << "impossible" << endl;
	}else{
		cout << res << endl;
	}
	return 0;
}
