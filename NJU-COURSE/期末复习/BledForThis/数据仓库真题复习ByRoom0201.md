# 一 数据仓库

## 算法一：位图索引（BITMAP）

![image-20201209214057042](https://gitee.com/CTLQAQ/picgo/raw/master/image-20201209214057042.png)

a)

作用：数据仓库是一个面向主题的，集成的，时变的，非易失的数据集合，通过数据清理、变换、继承、装入和定期刷新等方法，从一个或多个数据源收集信息，存放在一个一致的模式下。其能提供大量的，按照实际要求集成的不同主题的数据，通过OLAP引擎对其进行数据挖掘发现知识。

地位：是知识发现过程中不可缺少的一环，是进行数据挖掘必要基础。能提供非冗余的有效数据，且都面向主题，因此大大提高知识发现能力效率。没有数仓，知识发现就没有数据源。



b)  ①B树索引能用于多值索引，类似卡号，但数据仓库中常有性别等二值属性。

​      ②B树更适合于查询条件简单，结果少的状况，数据仓库返回的结果集较大。

​      ③B数索引时间空间开销大，对数据仓库来说不划算。

c)



# 四 分类

算法一：决策树

算法二：朴素贝叶斯

![image-20201209204327007](https://gitee.com/CTLQAQ/picgo/raw/master/image-20201209204327007.png)

**这一题，看过程就行了，不用在意数据**

1， 首先对age 和 income 进行排序

age： 21 23 25 29 31 34 34 38 40 45 49 50 55 57 61 66

income: 12000 15000 20000 22000 30000 36000 40000 45000 52000 55000 58000 65000 68000 70000 75000 78000

（66 - 21） / 3 = 15    （78 - 12）/ 3 = 22

所以等宽分桶后：

age:

 bin1 [21, 36): 21 23 25 29 31 34 34

 bin2 [36, 51): 38 40 45 49 50

 bin3 [51 66]: 55 57 61 66

income:

bin1 [1200, 34000): 12000 15000 20000 22000 30000

bin2 [34000, 56000): 36000 40000 45000 52000 55000

bin3 [56000, 78000]: 58000 65000 68000 70000 75000



2，由题意可知，共分为3类

class C1（< 1000）: 共4个

class C2 （1000...2000）共7个

class C3 （> 2000） 共5个

所以 I(C1, C2, C3) = I(5,7,4) = -4/16log4/16 - 7/16log7/16 - 5/16log5/16 = 1.55

**求age得信息增益**

| age           | C1i  | C2i  | C3i  | 总个数 |
| ------------- | ---- | ---- | ---- | ------ |
| Bin1 [21, 36) | 3    | 3    | 1    | 7      |
| Bin2 [36, 51) | 1    | 2    | 2    | 5      |
| Bin3 [51 66]  | 0    | 2    | 2    | 4      |

I(3,3,1) = -3/7log3/7  × 2 - 1/7log1/7 = 1.41

I(1,2,2) = -1/5log1/5 - 2/5log2/5 × 2 = 1.52

I(0,2,2) = -2/4log2/4 × 2 = 1

所以age得熵  E(age) = 7/16 * 1.41 + 5/16 * 1.52 + 4 / 16 * 1 = 1.34

∴ Gain(age) = I(C1, C2, C3) - E(age) = 0.21

**求income的信息增益**

| income              | C1i  | C2i  | C3i  | 总个数 |
| ------------------- | ---- | ---- | ---- | ------ |
| bin1 [1200, 34000)  | 3    | 2    | 0    | 5      |
| bin2 [34000, 56000) | 0    | 4    | 1    | 5      |
| bin3 [56000, 78000] | 1    | 1    | 4    | 6      |

同理

I(3,2,0) = 0.972 

I(0,4,1) = 0.72

I(1,4,1)=1.26

∴ E(Income) = 1

​    Gain(Income) = 1.55 - 1 = 0.55

**求student的信息增益**

| student | C1i  | C2i  | C3i  | 总个数 |
| ------- | ---- | ---- | ---- | ------ |
| yes     | 3    | 3    | 0    | 6      |
| no      | 1    | 4    | 5    | 10     |

同理

I(3,3,0) = 1

I(1,4,5) = 1.36

∴E(student) = 1.225

 Gain(student) = 1.55 - 1.225 = 0.33

综上：Gain(income) > Gain(student) > Gain(age)

所以按照属性Income分裂得到：

![image-20201209210158342](https://gitee.com/CTLQAQ/picgo/raw/master/image-20201209210158342.png)

按照Income分成的3个数据集合设为D1， D2, D3

**对于D1** 

I(C1, C2, C3) = I(3,2,0) = 0.972

求age得信息增益

| age           | C1i  | C2i  | C3i  | 总个数 |
| ------------- | ---- | ---- | ---- | ------ |
| Bin1 [21, 36) | 2    | 1    | 0    | 3      |
| Bin2 [36, 51) | 1    | 0    | 0    | 1      |
| Bin3 [51 66]  | 0    | 1    | 0    | 1      |

I(0,1,0)=0

I(1,0,0)=0

I(2,1,0)=0.88

∴ E(age) = 4/6 * 0.19 = 0.13

Gain(age) = 0.97 - 0.13 = 0.09

求student得信息增益

| student | C1i  | C2i  | C3i  | 总个数 |
| ------- | ---- | ---- | ---- | ------ |
| yes     | 3    | 1    | 0    | 4      |
| no      | 0    | 1    | 0    | 1      |

所以 

I(0,2,0) = 0

I(3,1,0) = 0.19

E(student) = 4/6 * 0.19 = 0.13

Gain(student) = 0.84

由于Gain(student) > Gain(age)所以对于D1  选择 student作为分裂属性 可得

![image-20201209211224128](https://gitee.com/CTLQAQ/picgo/raw/master/image-20201209211224128.png)

**对于数据集D2**

| age           | C1i  | C2i  | C3i  | 总个数 |
| ------------- | ---- | ---- | ---- | ------ |
| Bin1 [21, 36) | 2    | 0    | 0    | 2      |
| Bin2 [36, 51) | 0    | 2    | 0    | 2      |
| Bin3 [51 66]  | 0    | 0    | 1    | 1      |

可得E(age)=0

所以Gain(age) >= G(student)

所以选择age作为分裂属性

![image-20201209211832779](https://gitee.com/CTLQAQ/picgo/raw/master/image-20201209211832779.png)

**对于数据集合D3**

可以直接按照 age进行分裂，因为：E(student)=I(1,1,4) 所以Gain(student)=0，进而 Gain(age)>=Gain(student)

I(1,1,4)=1.26

| age           | C1i  | C2i  | C3i  | 总个数 |
| ------------- | ---- | ---- | ---- | ------ |
| Bin1 [21, 36) | 1    | 0    | 1    | 2      |
| Bin2 [36, 51) | 0    | 0    | 2    | 2      |
| Bin3 [51 66]  | 0    | 1    | 1    | 2      |

I(1,0,1)=1

I(0,1,1)=1

I(0,0,2)=0

所以E(age)=0.66  G(age)=1.26-0.66=0.6

| student | C1i  | C2i  | C3i  | 总个数 |
| ------- | ---- | ---- | ---- | ------ |
| yes     | 1    | 1    | 4    | 6      |
| no      | 0    | 0    | 0    | 0      |

可得E(age)=1.26

所以选择 age作为分裂属性，可得

![image-20201209204737119](https://gitee.com/CTLQAQ/picgo/raw/master/image-20201209204737119.png)

对于最后得到得数据集合，因为只剩最后一个属性，直接选择剩下那个作为分裂属性，可得：

![image-20201209204754975](https://gitee.com/CTLQAQ/picgo/raw/master/image-20201209204754975.png)



3，对于元组（24，75000，yes）

看树，可得其分类为    Class:buy_MP = >2000



![image-20201209204834881](https://gitee.com/CTLQAQ/picgo/raw/master/image-20201209204834881.png)

1， 首先对age 和 income 进行排序

age： 21 23 25 29 31 34 34 38 40 45 49 50 55 57 61 66

income: 12000 15000 20000 22000 30000 36000 40000 45000 52000 55000 58000 65000 68000 70000 75000 78000

（66 - 21） / 3 = 15    （78 - 12）/ 3 = 22

所以等宽分桶后：

age:

 bin1 [21, 36): 21 23 25 29 31 34 34

 bin2 [36, 51): 38 40 45 49 50

 bin3 [51 66]: 55 57 61 66

income:

bin1 [1200, 34000): 12000 15000 20000 22000 30000

bin2 [34000, 56000): 36000 40000 45000 52000 55000

bin3 [56000, 78000]: 58000 65000 68000 70000 75000



2，设元组X=(24，75000，yes)=(age_bin1,income_bin3,student=yes)=(a,b,c)

class C1（< 1000）: 共4个

class C2 （1000...2000）共7个

class C3 （> 2000） 共5个

| age           | C1i  | C2i  | C3i  | 总个数 |
| ------------- | ---- | ---- | ---- | ------ |
| Bin1 [21, 36) | 3    | 3    | 1    | 7      |

| income              | C1i  | C2i  | C3i  | 总个数 |
| ------------------- | ---- | ---- | ---- | ------ |
| bin3 [56000, 78000] | 1    | 1    | 4    | 6      |

| student | C1i  | C2i  | C3i  | 总个数 |
| ------- | ---- | ---- | ---- | ------ |
| yes     | 3    | 3    | 0    | 6      |

所以可得条件概率

P(a|C1) = 3/4		P(a|C2)=3/7		 P(a|C3)=1/5

P(b|C1) = 1/4		P(b|C2)=1/7		 P(b|C3)=4/5

P(c|C1)=3/4		P(c|C2)=3/7		 P(c|C3)=0

所以

P(X|C1)*P(C1)=3/4 * 1/4 * 3/4 * 4/16=9/259(最大)

P(X|C2)*P(C2)=3/7 * 1/7 * 3/7 * 7/16 = 9/720

P(X|C3)*P(C3)=0

所以，对于元组X，朴素贝叶斯预测它得类为 Class:buy_MP<1000