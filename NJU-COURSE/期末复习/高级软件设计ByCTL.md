# 1 模式比较

## 适配器VS装饰者VS外观

从目的出发，进行比较

- 适配器将一个对象包装起来以改变其接口
- 装饰者将一个对象包装起来以增加新的行为和责任
- 外观将一群对象包装起来以简化其接口

## 外观与适配器的差异？

- 外观和适配器可以包装许多类，但是外观的意图是简化接口,让一个子系统更加容易使用，而适配器的意图是将接口转换成不同接口。

## 对比简单工厂和工厂模式

- 简单工厂把全部事情在一个地方都处理完了，然而工厂方法确实创建一个框架，让子类决定要如何实现。简单工厂只是将对象的创建封装起来，不具备工厂方法的弹性，不能变更正在创建的产品。

## 对比策略模式和状态模式

状态模式和策略模式的类图一摸一样。

区别：

- 状态模式将一群行为封装在状态对象中，context的行为可以随时委托到状态中的一个。**随着时间的流逝，当前的状态在状态集合中游走变化，以反映context内部的状态。**
- 策略模式，客户通常主动指定context所要组合的策略对象是哪一个。虽然策略模式让我们更加有弹性，能够在运行时改变策略，但是对于某个context对象来说，通常**只有一个最恰当的策略对象**。
- 把策略模式当成除了继承以外的方案，可以通过组合不同的对象改变类的行为。
- 把状态模式当成不用再context中放置许多条件判断的代替方案。将行为包装进状态的对象中，可以通过在context内简单的改变状态对象来改变context的行为。

## 对比工厂模式和抽象工厂

- 都负责创建对象，将客户从具体类型中解耦，提高弹性。
- 工厂通过子类创建对象，子类决定具体类型，但是只能创建一个产品。

- 抽象工厂可以创建产品家族或将一群相关产品集合起来，但是有新产品把必须修改接口，其中的具体工厂会使用工厂方法创建产品。

# 2 原则

## OO 原则

- 封装变化；

- 多用组合少用继承；（合成复用原则）

- 针对接口编程，不针对实现编程；（依赖倒转原则）

- 为交互对象之间松耦合设计而努力；

- 类应该对扩展开放，对修改关闭；（开闭原则）

- 依赖抽象，不是依赖具体类；

- 只和朋友交谈；（迪米特法则）

- **别来找我，我会找你**；在这个原则之下，允许低层组件将自己挂钩到系统之上，但是高层组件会决定什么时候和怎样使用这些底层组件。（**工厂方法、观察者**、**模板方法**）都采用了**好莱坞原则**）

- 类应该只有一个改变的理由。（单一职责原则）

## 软件设计原则

- **单一职责原则**（Single responsibility principle）： 一个类，只有一个引起它变化的原因，只有一个职责。

- **开闭原则**： 一个软件实体如类、 模块和函数应该对扩展开放，对修改关闭。模块应尽量在不修改原（是“原”，指原来的代码）代码的情况下进行扩展。

- **里氏替换原则**（ Liskov Substitution Principle）： 任何基类可以出现的地方，子类一定可以出现。 **LSP 是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为**。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。（such as 装饰者模式）

- **依赖倒置原则**（ Dependency Inversion Principle）： 程序要依赖于抽象接口，不要依赖于具体实现。简单的说就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。 **面向接口编程，而不是面向实现编程**。 即要面向抽象编程，而不是面向具体编程。高层模块依赖高层模块，细节依赖抽象。

- **接口隔离原则**： 客户端不应该依赖它不需要的接口， 类间的依赖关系应该建立在最小的接口上。

- **合成复用原则**（Composite/Aggregate Reuse Principle）： 合成/聚合复用原则就是在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分；新的对象通过向这些对象的委派达到复用已有功能的目的。它的设计原则是： 要尽量使用合成/聚合，尽量不要使用继承。

- **迪米特法则**（ Law of Demeter、 Least Knowledge Principle）： 一个对象应当对其他对象有尽可能少的了解， 不和陌生人说话。

# 3 各种模式

## 观察者模式（组合）

Observer，Publish-Subscribe

#### 定义

定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。

#### 类图

![image-20201208141129376](https://gitee.com/CTLQAQ/picgo/raw/master/image-20201208141129376.png)

#### 注意点

- ConcreateObserver需要保存一个对主题的引用，这样以后如果想**取消注册**的时候会比较方便。
- 使用该模式可以从被观察者推（push）或（pull）数据（然而，**推的方式被认为更正确**）。

**拉模式举例**

![image-20201208141341364](https://gitee.com/CTLQAQ/picgo/raw/master/image-20201208141341364.png)

![image-20201208141635620](https://gitee.com/CTLQAQ/picgo/raw/master/image-20201208141635620.png)

- Subject类，调用notifyObservers时没有使用参数，表示将使用拉模式。因为被通知者update被调用的时候将会使用主题的get方法获取自己想要的数据。

**推模式举例**

![image-20201208141844092](https://gitee.com/CTLQAQ/picgo/raw/master/image-20201208141844092.png)

![image-20201208141859010](https://gitee.com/CTLQAQ/picgo/raw/master/image-20201208141859010.png)

![image-20201208141918330](https://gitee.com/CTLQAQ/picgo/raw/master/image-20201208141918330.png)

## 简单工厂

这是一种方法而不是模式，它利用了静态方法，所以又叫作静态工厂，不需要使用创建对象的方法来实例化对象，它将很多变化封装在一起成为一个静态类。但是缺点是不能通过继承来改变创建方法的行为。

![image-20201208142131209](https://gitee.com/CTLQAQ/picgo/raw/master/image-20201208142131209.png)



## 工厂方法模式

Factory Method

#### 定义

定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。**把实例化推迟到子类中**。

#### 类图

![image-20201208142624278](https://gitee.com/CTLQAQ/picgo/raw/master/image-20201208142624278.png)



#### 符合的OO原则

- 增加新的产品类只需要增加一个具体的工厂，而不用修改源代码，符合**开闭原则**
- 每一个工厂对象，只负责生产一个类的对象，符合**单一职责原则**。
- 客户端不需要依赖具体的产品类，符合**依赖抽象，不是依赖具体类**（依赖倒转原则）

## 抽象工厂模式

#### 定义

提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。

在抽象工厂模式中，产品族的概念是使用抽象工厂的关键，**产品族是指一个对象需要依赖一组相关的其他对象。**

#### 类图

![image-20201208142934389](https://gitee.com/CTLQAQ/picgo/raw/master/image-20201208142934389.png)

#### 优缺点

优点：

- 隔离了具体类的生产过程，客户不知道需要创建哪些对象（减少了客户端对产品的依赖；
- 能够保证相互依赖的一组对象始终属于同一个产品族；
- 增加新的产品族和工厂很简单，符合“开闭原则”。

缺点：

- 当需要新增产品的产品族结构时，将需要修改所有工厂类，破坏了“开闭原则”



## 单件模式

#### 定义

单例模式可确保一个类只有一个实例，并提供对其的全局访问点。



